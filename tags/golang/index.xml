<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on divan&#39;s blog</title>
    <link>https://divan.github.io/tags/golang/index.xml</link>
    <description>Recent content in Golang on divan&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://divan.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to avoid Go gotchas</title>
      <link>https://divan.github.io/posts/avoid_gotchas/</link>
      <pubDate>Fri, 04 Nov 2016 13:25:35 +0100</pubDate>
      
      <guid>https://divan.github.io/posts/avoid_gotchas/</guid>
      <description>

&lt;h5 id=&#34;tl-dr-by-learning-internals&#34;&gt;TL;DR  by learning internals&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;a gotcha is a valid construct in a system, program or programming language that works as documented but is counter-intuitive and almost invites mistakes because it is both easy to invoke and unexpected or unreasonable in its outcome
(source: &lt;a href=&#34;https://en.wikipedia.org/wiki/Gotcha_(programming)&#34;&gt;wikipedia&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Go programming language has some gotchas and there is a &lt;a href=&#34;https://go-traps.appspot.com&#34;&gt;number&lt;/a&gt; of &lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&#34;&gt;good articles&lt;/a&gt; &lt;a href=&#34;https://medium.com/@Jarema./golang-slice-append-gotcha-e9020ff37374#.xvfl7r4ti&#34;&gt;explaining&lt;/a&gt; them. I find those articles very important, especially for the newcomers in Go, as I see people run into those gotchas every now and then.&lt;/p&gt;

&lt;p&gt;But one question was bugging me for a long time - why I never ran into most of these gotchas? Seriously, most famous of them, like &amp;ldquo;nil interface&amp;rdquo; confusion or &amp;ldquo;slice append&amp;rdquo; issue was never an issue for me. I somehow avoided those problems from the very first days of working with Go. Why is it so?&lt;/p&gt;

&lt;p&gt;And the answer was actually simple. It turned out that I was lucky enough to read some articles about internal representations of Go data structures and learn some basics of how things work internally in Go. And that knowledge was enough to build intuition about Go and avoid those gotchas.&lt;/p&gt;

&lt;p&gt;Remember, &lt;em&gt;&amp;ldquo;gotchas are .. valid constructs .. but is counter-intuitive&amp;rdquo;&lt;/em&gt;? That is it. You have only two options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;fix&amp;rdquo; the language&lt;/li&gt;
&lt;li&gt;fix the intuition&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Second is actually would be better seen as &lt;em&gt;build the intuition&lt;/em&gt;. Once you have a clear mental image of how slices or interfaces work under the hood, it&amp;rsquo;s almost impossible to run into those mistakes.&lt;/p&gt;

&lt;p&gt;So, it worked for me and probably will work for others. That&amp;rsquo;s why I decided to gather that basic knowledge of some Go internals in this post and help people to build the intuition about an in-memory representation of different things.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start from basic understanding how things are represented in memory. Quick overview of what we&amp;rsquo;re going to learn:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#pointers&#34;&gt;Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#arrays-and-slices&#34;&gt;Arrays and slices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#append&#34;&gt;Append&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#interfaces&#34;&gt;Interfaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#empty-interface&#34;&gt;Empty interface&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;pointers&#34;&gt;Pointers&lt;/h1&gt;

&lt;p&gt;Go is pretty close to the hardware, actually. When you create a 64-bit integer (&lt;code&gt;int64&lt;/code&gt;) variable you know exactly how much memory it takes, and you can use &lt;a href=&#34;https://golang.org/pkg/unsafe/#Sizeof&#34;&gt;unsafe.Sizeof()&lt;/a&gt; for calculating the size of any other type.&lt;/p&gt;

&lt;p&gt;I often use visualization of memory blocks to &amp;ldquo;see&amp;rdquo; the sizes of the variables, arrays, and data structures. Visual representation gives you an easy way to get the intuition about types and often helps to reason about behavior and performance.&lt;/p&gt;

&lt;p&gt;For the warm-up let&amp;rsquo;s visualize most basic types in Go:
&lt;img src=&#34;https://divan.github.io/images/basic_types.png&#34; alt=&#34;Basic types&#34; /&gt;
Assuming you&amp;rsquo;re on the 32-bit machine &lt;em&gt;(which is probably false nowadays)&lt;/em&gt;, you can see that &lt;em&gt;int64&lt;/em&gt; takes twice as much memory as &lt;em&gt;int32&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A bit more complicated an internal representation of pointers - in fact, it&amp;rsquo;s the one block in memory, which contains a memory address to some other region in memory, where actual data is stored.  When you hear the fancy word &lt;em&gt;&amp;ldquo;dereferencing a pointer&amp;rdquo;&lt;/em&gt; it actually means &lt;em&gt;&amp;ldquo;getting to the actual memory blocks by an address stored in the pointer variable&amp;rdquo;&lt;/em&gt;. You may imagine it like this:
&lt;img src=&#34;https://divan.github.io/images/pointers.png&#34; alt=&#34;Pointers&#34; /&gt;
Address in memory is usually represented by hex value, hence &lt;em&gt;&amp;ldquo;0x&amp;hellip;&amp;rdquo;&lt;/em&gt; in the picture. But the knowing that &amp;ldquo;pointer&amp;rsquo;s value&amp;rdquo; may be in one place, while &amp;ldquo;actual data, referenced by pointer&amp;rdquo; - in another, will help us in the future.&lt;/p&gt;

&lt;p&gt;Now, one of the &amp;ldquo;gotchas&amp;rdquo; for the beginners in Go, especially who has no prior knowledge of languages with pointers, is a confusion between &amp;ldquo;passing by value&amp;rdquo; of function parameters. As you may know, in Go everything is passed &amp;ldquo;by value&amp;rdquo;, i.e. by copying.
It should be much easier, once you try to visualize this copying:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/func_params.png&#34; alt=&#34;Func params&#34; /&gt;
In a first case, you copy all those blocks of memory - and in reality, it&amp;rsquo;s often much more than 2 - it may easily be 2 million of blocks, and you have to copy them all, which is one of the most expensive operations. But in the second case, you copy only one block of memory - which contains the address of actual data - and is fast and cheap.&lt;/p&gt;

&lt;p&gt;Now, you naturally can see that modifying &lt;code&gt;p&lt;/code&gt; in the function &lt;code&gt;Foo()&lt;/code&gt; will not modify original data in a first case, but definitely will modify in the second case as the address stored in &lt;code&gt;p&lt;/code&gt; is referencing original data blocks.&lt;/p&gt;

&lt;p&gt;Okay, if you got the gist of how knowing internal representations can help you avoid common gotchas, let&amp;rsquo;s dive a bit deeper.&lt;/p&gt;

&lt;h1 id=&#34;arrays-and-slices&#34;&gt;Arrays and Slices&lt;/h1&gt;

&lt;p&gt;Slices at the beginning are often confused with arrays. So let&amp;rsquo;s take a look at arrays.&lt;/p&gt;

&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;arr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;arr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;arr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Arrays are just continuous  blocks of memory, and if you check the Go runtime source code (&lt;a href=&#34;https://golang.org/src/runtime/malloc.go#L793&#34;&gt;src/runtime/malloc.go&lt;/a&gt;), you may see that creating an array is essentially an allocating a piece of memory of the given size. Old good malloc, just smarter :)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// newarray allocates an array of n elements of type typ.&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newarray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;typ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;maxSliceCap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;typ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;plainError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;runtime: allocation size out of range&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mallocgc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;typ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;typ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What does it mean for us? It means that we can simply represent array as a set of blocks in memory sitting next to each other:
&lt;img src=&#34;https://divan.github.io/images/array.png&#34; alt=&#34;Array&#34; /&gt;
Array elements are always initialized with &lt;em&gt;zero values&lt;/em&gt; of its type, 0 in our case of &lt;code&gt;[5]int&lt;/code&gt;. We can index them and get the length using &lt;code&gt;len()&lt;/code&gt; built-in command. Nothing else, basically.
When you refer to the single element in the array by index and doing something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;arr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;42&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;you&amp;rsquo;re taking the fifth (4+1) element and change its value:
&lt;img src=&#34;https://divan.github.io/images/array2.png&#34; alt=&#34;Array 2&#34; /&gt;
Now, we&amp;rsquo;re ready to explore the slices.&lt;/p&gt;

&lt;h3 id=&#34;slices&#34;&gt;Slices&lt;/h3&gt;

&lt;p&gt;Slices at the first glance are similar to arrays, and the declaration is really similar:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But if we go to the Go source code (&lt;a href=&#34;https://golang.org/src/runtime/slice.go#L11&#34;&gt;src/runtime/slice.go&lt;/a&gt;), we&amp;rsquo;ll see that, in fact, Go&amp;rsquo;s slices are structures with three fields - pointer to array, length and capacity:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;array&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;len&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When you create a new slice, Go runtime will create this three-blocks&amp;rsquo; object in memory with the pointer set to &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; and &lt;code&gt;cap&lt;/code&gt; set to 0. Let&amp;rsquo;s represent it visually:
&lt;img src=&#34;https://divan.github.io/images/slice1.png&#34; alt=&#34;Slice 1&#34; /&gt;
That&amp;rsquo;s not very interesting, so let&amp;rsquo;s use &lt;code&gt;make&lt;/code&gt; to initialize slice of the given size:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;will create a slice with an underlying array of 5 elements, initialized with 0, and will set both &lt;code&gt;len&lt;/code&gt; and &lt;code&gt;cap&lt;/code&gt; to 5.
Cap means capacity and helps to reserve more space for the future growth. You can use &lt;code&gt;make([]int, len, cap)&lt;/code&gt; syntax to specify capacity. If fact, you&amp;rsquo;re almost never will have to deal with that, but it&amp;rsquo;s important to understand the concept of capacity.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at both cases:
 &lt;img src=&#34;https://divan.github.io/images/slice2.png&#34; alt=&#34;Slice 2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, when you update some elements of the slice, you&amp;rsquo;re actually change the values in the underlying array.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;42&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/slice3.png&#34; alt=&#34;Slice 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That was easy. But what will happen, if you create another subslice and change some elements? Let&amp;rsquo;s try:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;42&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;bar&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;99&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/slice4.png&#34; alt=&#34;Slice 4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, you see it! By modifying &lt;code&gt;bar&lt;/code&gt;, you actually modified the underlying array, which is also referenced by slice &lt;code&gt;foo&lt;/code&gt;.  And it&amp;rsquo;s actually a real thing, you may write something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;digitRegexp&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;regexp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;MustCompile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;[0-9]+&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;FindDigits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;filename&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ioutil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReadFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;digitRegexp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;By reading let&amp;rsquo;s say 10MB of data into slice and searching for only 3 digits, you may assume that you&amp;rsquo;re returning 3 bytes, but, in fact, the underlying array will be kept in memory, no matter how large it is.
 &lt;img src=&#34;https://divan.github.io/images/slice5.png&#34; alt=&#34;Slice 5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And that is one of the most common Go gotchas you may read about. But once you have this picture of internal slice representation in your head, I bet it will be almost impossible to run into it!&lt;/p&gt;

&lt;h1 id=&#34;append&#34;&gt;Append&lt;/h1&gt;

&lt;p&gt;Next to the slices&amp;rsquo; gotchas, there are some gotchas related to the built-in generic function &lt;code&gt;append()&lt;/code&gt;. It essentially does one operation - appends a value to the slice, but internally it does a lot of complex stuff, allocating memory in a smart and efficient way if needed.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take the following code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It creates a new slice of 32 ints and adds new (33rd) element.&lt;/p&gt;

&lt;p&gt;Remember &lt;code&gt;cap&lt;/code&gt; - capacity in the slices? Capacity stands for &lt;em&gt;capacity to grow&lt;/em&gt;. &lt;code&gt;append&lt;/code&gt; checks if the slice has some more capacity to grow and, if not, allocates more memory. Allocating memory is a quite expensive operation, so &lt;code&gt;append&lt;/code&gt; tries to anticipate that operation and asks not for 1 byte, but for 32 bytes more - twice as large as the original capacity. Again, allocating more memory in one go is generally cheaper and faster than allocating less memory many times.&lt;/p&gt;

&lt;p&gt;The confusing part here is that, for many reasons, allocating more memory usually means allocating it at the different address and moving data from old place to the new one. It means that address of the underlying array in the slice will also change. Let&amp;rsquo;s visualize this:
 &lt;img src=&#34;https://divan.github.io/images/append.png&#34; alt=&#34;Append&#34; /&gt;
It&amp;rsquo;s easy to see two underlying arrays - old and new ones. Doesn&amp;rsquo;t look like a possible gotcha, right? The old array will be freed by GC later unless another slice is referring it. This case, actually, is one of the gotchas with append. What if you create subslice &lt;code&gt;b&lt;/code&gt;, then append a value to &lt;code&gt;a&lt;/code&gt;, assuming they both share common underlying array?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;42&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You will get this:
 &lt;img src=&#34;https://divan.github.io/images/append2.png&#34; alt=&#34;Append 2&#34; /&gt;
Yes, you&amp;rsquo;ll have two different underlying arrays and it may be quite contra-intuitive for the beginners. So, as a rule of thumb, be careful when you use subslices, and especially, subslices with append.&lt;/p&gt;

&lt;p&gt;By the way, &lt;code&gt;append&lt;/code&gt; grows slice by doubling it&amp;rsquo;s capacity only up to 1024, after that it will use so-called &lt;a href=&#34;https://golang.org/src/runtime/msize.go&#34;&gt;memory size classes&lt;/a&gt; to guarantee that growth will be no more than ~12.5%. Requesting 64 bytes for 32 bytes array is ok, but if your slice is 4GB, allocating another 4GB for adding 1 element is quite expensive, so it makes sense.&lt;/p&gt;

&lt;h1 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h1&gt;

&lt;p&gt;Okay, this is the most confusing thing for many people. It takes some time to wrap your head around proper usage of interfaces in Go, especially after having a traumatic experience with class-based languages. And one of the sources of confusion is a different meaning of &lt;code&gt;nil&lt;/code&gt; keyword in the context of interfaces.&lt;/p&gt;

&lt;p&gt;To help understand this subject, let&amp;rsquo;s again take a look at the Go source code. What is interface under the hood? Here is a code from &lt;a href=&#34;https://golang.org/src/runtime/runtime2.go#L143&#34;&gt;src/runtime/runtime2.go&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;iface&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;tab&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;itab&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;itab&lt;/code&gt; stand for &lt;em&gt;interface table&lt;/em&gt; and is also a structure that holds needed meta information about interface and underlying type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;itab&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;inter&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;interfacetype&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;_type&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_type&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;link&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;itab&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;bad&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;unused&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fun&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// variable sized&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We&amp;rsquo;re not going to learn the logic of how interface type assertion works, but what is important is to understand that &lt;em&gt;interface&lt;/em&gt; is a compound of interface and static type information plus pointer to the actual variable (field &lt;code&gt;data&lt;/code&gt; in &lt;code&gt;iface&lt;/code&gt;). Let&amp;rsquo;s create variable &lt;code&gt;err&lt;/code&gt; of interface type &lt;code&gt;error&lt;/code&gt; and represent it visually:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/iface1.png&#34; alt=&#34;Interface1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In fact, what you see in this picture is the thing called &lt;em&gt;nil interface&lt;/em&gt;. When you return nil in the function with return type &lt;code&gt;error&lt;/code&gt;, you are returning this object. It has information about interface (&lt;code&gt;itab.inter&lt;/code&gt;), but has &lt;code&gt;nil&lt;/code&gt; in &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;itab.type&lt;/code&gt; fields. This object will evaluate to true in the &lt;code&gt;if err == nil {}&lt;/code&gt;  condition.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// nil&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, famous gotcha is to return a &lt;code&gt;*os.PathError&lt;/code&gt; variable which is &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PathError&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// nil&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Those two pieces of code are similar unless you know how the interface looks like inside. Let&amp;rsquo;s represent this &lt;code&gt;nil&lt;/code&gt; variable of type &lt;code&gt;*os.PathError&lt;/code&gt; being wrapped in an &lt;code&gt;error&lt;/code&gt; interface:
 &lt;img src=&#34;https://divan.github.io/images/iface2.png&#34; alt=&#34;Interface2&#34; /&gt;
You can clearly see the &lt;code&gt;*os.PathError&lt;/code&gt; variable - it&amp;rsquo;s just a block of memory holding &lt;code&gt;nil&lt;/code&gt; value because it&amp;rsquo;s the zero value for pointers. But the actual &lt;code&gt;error&lt;/code&gt; that we return from &lt;code&gt;foo()&lt;/code&gt; is a much complex structure with information about the interface, about the underlying type and the memory address of that block of memory, holding &lt;code&gt;nil&lt;/code&gt; pointer. Feel the difference?&lt;/p&gt;

&lt;p&gt;In both cases, we have &lt;code&gt;nil&lt;/code&gt;, but there is a huge difference between &lt;em&gt;&amp;ldquo;have an interface with a variable which value equals to nil&amp;rdquo;&lt;/em&gt; and &lt;em&gt;&amp;ldquo;interface without variable&amp;rdquo;&lt;/em&gt;. Having this knowledge of internal structure of interfaces, try to confuse these two examples now:
 &lt;img src=&#34;https://divan.github.io/images/iface3.png&#34; alt=&#34;Interface3&#34; /&gt;
Should be much harder now to run into that gotcha.&lt;/p&gt;

&lt;h3 id=&#34;empty-interface&#34;&gt;Empty interface&lt;/h3&gt;

&lt;p&gt;A few words about &lt;em&gt;empty interface&lt;/em&gt; - &lt;code&gt;interface{}&lt;/code&gt;. In the Go source code (&lt;a href=&#34;https://golang.org/src/runtime/runtime2.go#L148&#34;&gt;src/runtime/malloc.go&lt;/a&gt; it&amp;rsquo;s implemented using own structure - &lt;code&gt;eface&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;eface&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_type&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you may see, it&amp;rsquo;s similar to &lt;code&gt;iface&lt;/code&gt;, but lacks interface table. It just does not need one because by definition empty interface is implemented by any static type. So when you wrap something - explicitly or implicitly (by passing as a function argument, for example) - into &lt;code&gt;interface{}&lt;/code&gt;, you actually working with this structure:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;42&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/eface.png&#34; alt=&#34;Empty Interface&#34; /&gt;&lt;/p&gt;

&lt;p&gt;One of the &lt;code&gt;interface{}&lt;/code&gt; related gotchas is the frustration that you can&amp;rsquo;t easily assign slice of interfaces to slice of concrete types and vice versa. Something like&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You&amp;rsquo;ll get compile time error:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span&gt;&lt;/span&gt;$ go build
cannot use &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;int literal &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;int&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; as &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;interface &lt;span class=&#34;o&#34;&gt;{}&lt;/span&gt; in &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; argument
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It&amp;rsquo;s confusing and the beginning. Like, why I can do this conversion with a single variable, but cannot do with slice? But once you know what is an empty interface (take a look at the picture above again), it becomes pretty clear, that this &amp;ldquo;conversion&amp;rdquo; is actually a quite expensive operation which involves allocating a bunch of memory and is around O(n) of time and space. And one of the common approaches in Go design is &lt;strong&gt;&amp;ldquo;if you want to do something expensive - do it explicitly&amp;rdquo;&lt;/strong&gt;.
 &lt;img src=&#34;https://divan.github.io/images/eface_slice.png&#34; alt=&#34;Slice Interface&#34; /&gt;
Hopefully, it makes sense to you now as well.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Not every gotcha can be attacked by learning internals. Some of them are simply the difference between your past and new experience, and we&amp;rsquo;re all have somehow different background and experience. Nevertheless, there a many of the gotchas that can be successfully avoided simply by understanding a bit deeper how Go works. I hope explanations in this post will help you build intuition on what is happening inside your programs and will make you a better developer. Go is your friend, and knowing it a bit better would not hurt anyway.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re interested in reading more about Go internals, here are a list of links that helped me:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://research.swtch.com/godata&#34;&gt;Go Data Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://research.swtch.com/interfaces&#34;&gt;Go Data Structures: Interfaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go-slices-usage-and-internals&#34;&gt;Go Slices: usage and internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://talks.godoc.org/github.com/davecheney/presentations/gopher-puzzlers.slide&#34;&gt;Gopher Puzzlers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And, of course, timeless source of usefull stuff :)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/&#34;&gt;Go source code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/effective_go.html&#34;&gt;Effective Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;Go spec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Happy hacking!&lt;/p&gt;

&lt;p&gt;PS. I also gave a similar talk on &lt;a href=&#34;http://www.meetup.com/Golang-Barcelona/&#34;&gt;Golang BCN&lt;/a&gt; Meetup in November &amp;lsquo;16.&lt;/p&gt;

&lt;p&gt;Here are the slides: &lt;a href=&#34;http://divan.github.io/talks/2016/bcn/HowToAvoidGoGotchas.pdf&#34;&gt;How To Avoid Go Gotchas.pdf&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My GopherCon experience</title>
      <link>https://divan.github.io/posts/gophercon16/</link>
      <pubDate>Wed, 03 Aug 2016 19:28:46 +0200</pubDate>
      
      <guid>https://divan.github.io/posts/gophercon16/</guid>
      <description>

&lt;p&gt;A couple of weeks ago I gave a talk at the largest Go conference, &lt;a href=&#34;http://gophercon.com&#34;&gt;GopherCon&lt;/a&gt;, in Denver. It was the first time I attended GopherCon at all, and the first time ever I spoke in English in front of 1400+ people, and it was an absolutely incredible experience. Here is my story.&lt;/p&gt;

&lt;p&gt;My journey to GopherCon started on a cold winter day in the apartments in the center of Odessa, Ukraine, where I was living at that time. I was one of the organizers of the first Go meetup in Lviv (Ukraine) and have prepared one general talk about Go. We targeted mainly newcomers, so I wanted to make another talk that would share my passion and admiration of some of the coolest aspects of Go - concurrency.&lt;/p&gt;

&lt;h3 id=&#34;idea&#34;&gt;Idea&lt;/h3&gt;

&lt;p&gt;I started to think how to show the beauty and easiness of writing concurrent programs in Go. There are numerous blog posts and talks on this subject, but I wanted something more appealing for the absolute beginners. With my love for good visualizations, my thoughts slipped into an attempt to visualize concurrency in some fancy way. At the last &lt;a href=&#34;http://www.dotgo.eu&#34;&gt;dotGo&lt;/a&gt; conference in Paris, I was impressed by &lt;a href=&#34;https://www.youtube.com/watch?v=TI8OW22WZvQ&#34;&gt;Matt Aimonetti&amp;rsquo;s talk&lt;/a&gt; where he was using hardware with LEDs to demonstrate program flow. It was really nice and inspiring talk, so I decided to take this idea further and use a lot of LEDs to show goroutines and channels with colors and lights. That&amp;rsquo;s gonna be cool!&lt;/p&gt;

&lt;p&gt;But pretty soon I realized that I simply don&amp;rsquo;t see a way how to show it in a clear and beautiful way. Colored lights is a cool idea, but it should convey and demonstrate concurrency concepts in a first place. That led me to rethink how I see concurrency flows in my mind and it was pretty much clear that I see it in 3D. After quick googling about &amp;ldquo;3D LEDs chains&amp;rdquo; I understood that at this moment my goal was not feasible with this approach.&lt;/p&gt;

&lt;p&gt;Okay, let&amp;rsquo;s try another way. I&amp;rsquo;ll draw it myself with nice visualization tools we have nowadays! There are a bunch of super nice JS frameworks for visualizing complex things, so I should get what I want in a couple of nights of coding. But this attempt failed as well - all those frameworks are well suited for representing 2D data, or for very specific 3D charts, but not for the custom 3D visualizations. Everything was suggesting to take a closer look at WebGL, and the only feasible option was to implement my idea myself from scratch.&lt;/p&gt;

&lt;h3 id=&#34;first-implementation&#34;&gt;First implementation&lt;/h3&gt;

&lt;p&gt;Next weekend I&amp;rsquo;ve spent writing some JS code and learning &lt;a href=&#34;http://threejs.org&#34;&gt;Three.js&lt;/a&gt; framework, which was surprisingly cool. I must admit that writing JS code is a pain for me and I had to go the SPA every evening to get rid of a stress and muscular spasms. In a week or so, I had a very simple demo of ping-pong code example, taken from &lt;a href=&#34;https://www.youtube.com/watch?v=QDDwwePbDtw&#34;&gt;Sameer Ajmani talk&lt;/a&gt;. It was very simple, with concurrency steps and timings hardcoded manually, but it was enough to get excited.&lt;/p&gt;

&lt;p&gt;Next challenge was to automate tracing concurrency steps and timings automatically from any Go program. My first attempt was to modify AST of the source and insert Println() calls saying something like &amp;ldquo;goroutine started&amp;rdquo;, &amp;ldquo;send to channel value X&amp;rdquo; and so on. After practicing some kung-fu with go/[ast,parser,types} packages, I came with the solution, but it was inherently flawed. It worked for very simple examples, where channels had the same name. For more complex examples I had to rename it manually, expand recursions and so on.&lt;/p&gt;

&lt;p&gt;Anyway, it was enough to create slides for the talk for the meetup. I &lt;a href=&#34;http://divan.github.io/talks/2016/lviv/#/&#34;&gt;gave a talk&lt;/a&gt;, but it was quite bad, as I almost didn&amp;rsquo;t prepare and I was mostly busy with organization and preparing the first talk. So in a few days, on my way home, on a train, I wrote an article &lt;a href=&#34;https://divan.github.io/posts/go_concurrency_visualize/&#34;&gt;&amp;ldquo;Visualising Concurrency in Go&amp;rdquo;&lt;/a&gt; and published it next day.
&lt;img src=&#34;https://divan.github.io/demos/gifs/primesieve.gif&#34; alt=&#34;PrimeSieve&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;article&#34;&gt;Article&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/posts/go_concurrency_visualize/&#34;&gt;Article&lt;/a&gt; was very well received. I was surprised by the number of responses, retweets, likes and stars. I got a few job proposals, letters asking permission to republish it or translate into another language. One of the letters was from &lt;a href=&#34;https://twitter.com/ajstarks&#34;&gt;Anthony Starks&lt;/a&gt;, the author of amazing SVG library &lt;a href=&#34;https://github.com/ajstarks/svgo&#34;&gt;SVGo&lt;/a&gt;, who asked if I&amp;rsquo;m considering to propose this idea as a talk for GopherCon. I didn&amp;rsquo;t even consider myself as a speaker at the conference of that level, but next day I actually sent the proposal without any expectations.&lt;/p&gt;

&lt;p&gt;In a few weeks, I got an email that my proposal has been accepted. I&amp;rsquo;m gonna be speaking at GopherCon! Wow!&lt;/p&gt;

&lt;h3 id=&#34;preparing-to-gophercon&#34;&gt;Preparing to GopherCon&lt;/h3&gt;

&lt;p&gt;I felt thrilled, pleased and scared at the same time. First of all, I&amp;rsquo;ve never given a talk in English before. In fact, I didn&amp;rsquo;t even speak English on a daily basis those days. Second, I had to rewrite my initial approach in order to open source it and present at the conference. Third, I was facing the uncertainty of how scary this experience would be for me - giving a talk at the local meetup and at the conference with 1500+ people it&amp;rsquo;s not the same.&lt;/p&gt;

&lt;p&gt;The good thing is that I had time to prepare. More than 4 months of preparations! I even created a countdown on my watch, so I could track time left and prepare more efficiently.
&lt;img src=&#34;https://divan.github.io/images/gophercon_watch.jpg&#34; alt=&#34;Gophercon Watch Counter&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Around that time I read &lt;a href=&#34;http://waitbutwhy.com/2016/03/doing-a-ted-talk-the-full-story.html&#34;&gt;a post&lt;/a&gt; in my favorite blog &lt;a href=&#34;http://waitbutwhy.com&#34;&gt;&amp;ldquo;Wait But Why?&amp;rdquo;&lt;/a&gt; about author&amp;rsquo;s experience of preparation to his TED talk. It was a funny post, with some very important observations. One of the favorite topics of the author, Tim Urban, is a procrastination (actual topic of his talk, by the way) and he wrote how he spent most of the time procrastinating instead of preparing for the conference.&lt;/p&gt;

&lt;p&gt;Of course, I&amp;rsquo;m not like this. I have full 4 months ahead of me and I will use every day to do my best and prepare as best as I can!&lt;/p&gt;

&lt;h3 id=&#34;preparing-to-gophercon-again&#34;&gt;Preparing to GopherCon, again&lt;/h3&gt;

&lt;p&gt;Three months later I realized that I really have to stop procrastinating and start doing something.&lt;/p&gt;

&lt;p&gt;Okay, I had a good excuse. Around that time I changed my job and moved to Barcelona to work at &lt;a href=&#34;http://typeform.com&#34;&gt;Typeform&lt;/a&gt;. An exciting experience, great team and the company, but also a lot of time stolen from my preparation plans and coding. My new approach for tracing concurrency events was based on Dmitry Vyukov&amp;rsquo;s &lt;a href=&#34;https://docs.google.com/document/u/1/d/1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14/pub&#34;&gt;execution tracer&lt;/a&gt; and I actually did some initial coding. I also started speaking English on a daily basis which gave me some more confidence.&lt;/p&gt;

&lt;p&gt;I also read a great book, &lt;a href=&#34;https://www.google.es/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0ahUKEwjAhLL4s6jOAhXJtRQKHXQ7DKkQFggeMAA&amp;amp;url=https:%2F%2Fwww.ted.com%2Fread%2Fted-talks-the-official-ted-guide-to-public-speaking&amp;amp;usg=AFQjCNGBEk2GD2D6TUVX9-h8OYeBI6rNYA&#34;&gt;&amp;ldquo;The Official TED guide to Public Speaking&amp;rdquo;&lt;/a&gt; by Chris Anderson, the head of TED. It was a delightful reading and I highly recommend this book for anyone who interested in public speaking, TED conferences or both. It contains very deep insights of what really matters in public speaking. One of the main takeaways I got from this book is just to be yourself.&lt;/p&gt;

&lt;p&gt;I knew I&amp;rsquo;m gonna be speaking on the same stage with awesome speakers as Kelsey Hightower, Rob Pike and Dave Cheney, and I was not even close to them as a speaker. But I have an idea. An idea that people wanted to hear about. An idea that is somehow unique and interesting - that&amp;rsquo;s why my proposal was selected among others after all. I don&amp;rsquo;t have to try to be such an awesome speaker as Kelsey. Instead, I have to do it in my natural way. With my accent, my first timer&amp;rsquo;s nervousness and all this stuff. Just be yourself.&lt;/p&gt;

&lt;p&gt;I was slowly moving forward, wrote some initial script for the talk, was improving code step by step, and my first kind of rehearsal was scheduled for the end of June to speak at &lt;a href=&#34;http://www.meetup.com/Golang-Barcelona/&#34;&gt;Golang BCN&lt;/a&gt; meetup. This meetup was held in our office, and it went quite well for me.
&lt;img src=&#34;https://divan.github.io/images/gophercon_typeform.jpg&#34; alt=&#34;Typeform&#34; /&gt;
I wasn&amp;rsquo;t nervous at all, but I felt like I had almost no connection with people. I was extremely concentrated on my text, reciting it from memory and it felt  almost the same if I would have spoken to the wall. I didn&amp;rsquo;t like it. Audience feels this lack of personal connection immediately. Anyway, that rehearsal gave me another boost of confidence.&lt;/p&gt;

&lt;h3 id=&#34;before-gophercon&#34;&gt;Before GopherCon&lt;/h3&gt;

&lt;p&gt;Few days before the flight to Denver. I&amp;rsquo;m practicing talk every day, but here are two problems - lack of private space where I can practice loudly enough and failed attempt to use &lt;a href=&#34;https://www.leapmotion.com&#34;&gt;Leap Motion&lt;/a&gt; controller to handle visualization with hands. Well, it was not completely failed - I added code that allows me to use this awesome sensor in my presentation long time ago, but I was extremely unsatisfied with the result. My hope was that it&amp;rsquo;s just a question of practice, but then I realized that approach I used to rotate and zoom visualization is too error prone - any accidental hand movement would mess the scene.&lt;/p&gt;

&lt;p&gt;I solved the first problem by going to the sea in the late evening, and practicing talking to the sea - luckily, I live right near the beach and I have a luxury opportunity of having sunbath and swimming in the sea before going to work every day. Here is the view from my balcony:
&lt;img src=&#34;https://divan.github.io/images/gophercon_barcelona.jpg&#34; alt=&#34;Barcelona&#34; /&gt;
 And yeah, commute time to our awesome office is 12 minutes. And we are &lt;a href=&#34;http://typeform.com/careers&#34;&gt;hiring&lt;/a&gt; :)&lt;/p&gt;

&lt;p&gt;Regarding the Leap Motion issue, I decided to drop this idea and use fallback plan - usual trackpad, which is also fine. Time to pack bags.&lt;/p&gt;

&lt;h4 id=&#34;gophercon&#34;&gt;GopherCon!&lt;/h4&gt;

&lt;p&gt;At this point, I want to make a pause and express my gratitude to the GopherCon org team. They did an awesome job to organize and plan my trip to Denver at the highest level. I was also proposed to have a mentor for my talk, and I happily agreed to have one, but in the end, I decided to go through by myself. The flight itself and accomodation were simply amazing - long transatlantic flight went like a breeze (I watched UEFA Euro Final live on the plane!), and the hotel, which was just in front of Colorado Convention Center, was excellent. Special kudos for the room key design. Still lives in my wallet.
&lt;img src=&#34;https://divan.github.io/images/gophercon_key.jpg&#34; alt=&#34;Key&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, I&amp;rsquo;m in Denver. My flight arrived in the afternoon and it was a day of official rehearsal, so I rushed directly to the Convention Center, found a right hall, met Dave, Brian, Eric and others. Rehearsal went not that good as I expected - I forgot some words, Leap Motion controller messed up the scene, but I got the idea of how the room and the stage look like, so it was worth it anyway. Now time to go to the hotel, practice talk a few more times in a hotel room and sleep well after the long flight and make sure that jet lag won&amp;rsquo;t be a problem tomorrow - I have a talk on the morning session of the first day!&lt;/p&gt;

&lt;p&gt;Jet lag is much easier for me when flying from east to west, but it still breaks sleeping pattern. I woke up at 2:30am in a cold sweat - I had a dream that I overslept my talk. In a dream, brain doesn&amp;rsquo;t really know if it was for real or it was a dream, so the emotions were pretty real. Imagine my relief when I realised it was just a dream! Practicing talk in the morning again, breakfast, another practice in the room, time to go!&lt;/p&gt;

&lt;p&gt;An hour before the talk. I should have been nervous, but I haven&amp;rsquo;t. It&amp;rsquo;s my first public speaking experience, but I&amp;rsquo;m pretty excited to show my project to such an amazing community. It&amp;rsquo;s probably was the most important thing for me - atmosphere and people were super welcoming, and it killed much of nervousness at its roots. Like why should I be nervous if those people are so welcoming and I feel like even if I&amp;rsquo;m failed they will support me and cheer in any case! It was priceless. The only strong feeling I remember is an inability to relax, to start enjoying other talks and conversations - maximum concentration for the next hour!&lt;/p&gt;

&lt;p&gt;Finally, my turn! Kelsey is doing a great introduction, technicians are helping with a microphone, I&amp;rsquo;m placing my laptop onto the lectern, connecting Leap Motion (I decided to take a risk at the last moment!) and here we go! Not to mention my accent, I felt like my concentration paid off and I really enjoyed giving the talk. I memorized talk pretty well, so I could improvise a little bit, pay more attention to pauses and even try to make an eye contact with some people between the sentences. The bright lights of projectors made it difficult, but anyway, I felt great and when people burst into the laugh on a first joke, I felt even more confident. At the moment I&amp;rsquo;m writing this, there is not video published, so I&amp;rsquo;m safe to say it went well :) Anyhow, I really had fun doing this talk!
&lt;img src=&#34;https://divan.github.io/images/gophercon_gopher.jpg&#34; alt=&#34;Gopher&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The moment I left the stage was incredible. I was still excited, but there was nothing to worry about anymore and I could finally relax and start fully enjoying the conference and other talks.
In the next hours, I was approached by so many people and got so many kind words and responses. It was pleasant when people were coming to you just to say that your talk was great, but the most precious part of it is that the conversations were started naturally and I got a chance to meet so many awesome and talented people, I wouldn&amp;rsquo;t meet otherwise.&lt;/p&gt;

&lt;p&gt;That was my only big upset of the conference - there are so many great people, and it&amp;rsquo;s simply impossible to have conversations with all of them. I mean, it&amp;rsquo;s technically impossible. If I spend only 10 minutes per conversation, in order to cover all gophers I need 10 min x 1400 = 14K min = 233 hours = 9.72 days of non-stop conversations! And people are the most important part of any conference and any community. At GopherCon you can randomly meet people in a deli line and one guy will be from IBM Watson, another girl will be from Docker or Intel and you can end up sitting at the same table with a vim-go creator or even with Go authors itself! It&amp;rsquo;s amazing.&lt;/p&gt;

&lt;p&gt;The level of the conference organization and talks was also extremely high. One of the outstanding things was live captioning in real time. I&amp;rsquo;ve never seen that before and it looked like magic. :) There was a real person sitting in a special room, listening for what speakers were talking and she was transcripting it in real time using special software!
&lt;img src=&#34;https://divan.github.io/images/gophercon_caps.jpg&#34; alt=&#34;Caps&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The room was big and spacious, there was enough space for everyone and three gigantic screens made the experience comfortable even for the back rows of this huge hall.&lt;/p&gt;

&lt;p&gt;I have really enjoyed many talks, the range of topics was quite broad - from the hardcore internals of Go runtime implementation to the community growth discussions and a character study of Go gopher :) Organizers did a great job on selecting proposals and I felt really honored to be on stage with THAT people.&lt;/p&gt;

&lt;p&gt;Another special moment for me was a speaker&amp;rsquo;s dinner. I happened to be sitting at the same table as Rob Pike, Renee French, and Andrew Gerrand. Well, I&amp;rsquo;m not a fan or anything, but having dinner with such people is something I couldn&amp;rsquo;t even imagine. The place was pretty loud, and it was difficult to have a comfortable conversation, but anyway we talked not only about Go, but also about casual things, about Barcelona, figure skating, alcohol drinking culture, movies etc. And from my side, I really did enjoy the conversation, especially some answers and stories told. It wasn&amp;rsquo;t typical chit-chatting, for sure. So yeah, that dinner was quite special for me. Renee French drew (less than in a minute!) and presented to me that awesome picture of gopher doing figure skating! How talented she is!
&lt;img src=&#34;https://divan.github.io/images/gophercon_fs.jpg&#34; alt=&#34;Gopher&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s been more than three weeks already, but it still seems like GopherCon was just yesterday. It affected my view and understanding of Go community - it&amp;rsquo;s got REAL now. I mean, it&amp;rsquo;s not the first Go conference I&amp;rsquo;ve been to, but it wasn&amp;rsquo;t just a Go conference, it was a time and place where Go community becomes real. Twitter nicknames convert to the real people, Slack conversations transform into the face to face talks with a good food or coffee, and the distance between Go users and Go creators literally disappears. Is it normal to go to the tech conference and meet so many incredibly inspiring people?&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s now impossible to stay aside from the Go community concerns, problems and projects. I felt myself as a part of Go community before, but now it&amp;rsquo;s much more personal and deeper. The culture of respect and trust we have seems like something natural, but I know how many efforts have been put into it and how hard sometimes it&amp;rsquo;s been for some people on a personal level. I feel like I and all people who attended the conference are much more attached to the community now, and it&amp;rsquo;s in our power to help it grow and thrive.&lt;/p&gt;

&lt;p&gt;Here should go a huge list of thankyou&amp;rsquo;s.  To the GopherCon organizers to make this event happen and for the amazing job. To Go authors for making programming fun again, world a little bit happier and software a bit more robust. The core Go community members for moving our community through all growth problems and handling them gracefully. To WomenWhoGo chapters for bringing complex and important diversity questions onto the table and making our community better in general. To Anthony Starks for giving me initial push to send the proposal for GopherCon. To my friends who went to Denver to see and support me. To all members of Go community for being so open and welcoming, for creating an incredible amount of great software and packages. To newcomers in Go for not being afraid to dive into the new world and new community.
&lt;img src=&#34;https://divan.github.io/images/gophercon_community.jpg&#34; alt=&#34;Thankyou&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Thank you for the chance to meet all of you!&lt;/p&gt;

&lt;p&gt;PS. At the moment there is no official photos or videos available yet, I will update the post once they are published. So far, here is my slides: &lt;a href=&#34;http://divan.github.io/talks/2016/gophercon/#/&#34;&gt;http://divan.github.io/talks/2016/gophercon/#/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PPS. The project itself has been open-sourced and available here: &lt;a href=&#34;https://github.com/divan/gotrace&#34;&gt;https://github.com/divan/gotrace&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go get for private repos in docker</title>
      <link>https://divan.github.io/posts/go_get_private/</link>
      <pubDate>Wed, 01 Jun 2016 19:28:46 +0200</pubDate>
      
      <guid>https://divan.github.io/posts/go_get_private/</guid>
      <description>

&lt;p&gt;As Go community slowly moving towards established and well understood patterns and practices of dependency management, there are still some confusing moments. One of them is automating repeatable build process using containers along with using dependencies in private repositories.&lt;/p&gt;

&lt;p&gt;Private repositories on Github are often is a &lt;a href=&#34;https://github.com/golang/go/issues/9697&#34;&gt;source of confusion&lt;/a&gt; when using &lt;code&gt;go get&lt;/code&gt;, but it has easy workaround by adding two lines to your &lt;code&gt;.gitconfig&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[url &amp;quot;git@github.com:&amp;quot;]
	insteadOf = https://github.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or as a oneliner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global url.&amp;quot;git@github.com:&amp;quot;.insteadOf &amp;quot;https://github.com/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the most confusing part is trying to make the whole build process work inside the container. I will use Docker as an example, as it&amp;rsquo;s most popular container at the moment.&lt;/p&gt;

&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;

&lt;p&gt;Imagine, you have two packages &lt;code&gt;github.com/company/foo&lt;/code&gt; and &lt;code&gt;github.com/company/bar&lt;/code&gt;, where &lt;code&gt;foo&lt;/code&gt; imports &lt;code&gt;bar&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo.go:
import &amp;quot;github.com/company/bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In normal workflow, you setup GOPATH, you SSH keys, gitconfig and you&amp;rsquo;re done - simple &lt;code&gt;go get github.com/company/foo&lt;/code&gt; will work and download both packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -v github.com/company/foo
github.com/company/foo (download)
github.com/company/bar (download)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But now, you want to make the build process reproducible on any machine, even on CI instance, so you pack everything in Docker container. You will probably use simple Dockerfile based on official &lt;code&gt;golang&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dockerfile&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM golang:1.6

ADD . /go/src/github.com/company/foo
CMD cd /go/src/github.com/company/foo; go get github.com/company/bar &amp;amp;&amp;amp; go build -o /go/bin/foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Build script&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t foo-build . 				# build image
docker run --name=foo-build foo-build		# compile binary
docker cp foo-build:/foo foo				# copy binary to fs
docker rm -f foo-build						# remove container
docker rmi -f foo-build						# remove image
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This setup &lt;strong&gt;will not&lt;/strong&gt; work because Docker container used for building (foo-build) doesn&amp;rsquo;t container &lt;code&gt;bar&lt;/code&gt; dependency, SSH keys and proper gitconfig. And, apparently, it&amp;rsquo;s not trivial simply to add the keys - you have to deal with a bunch of obstacles, mainly on the SSH side. So, let&amp;rsquo;s go through quickly and setup working solution.&lt;/p&gt;

&lt;h2 id=&#34;the-solution&#34;&gt;The solution&lt;/h2&gt;

&lt;h3 id=&#34;ssh-vs-https&#34;&gt;ssh vs https&lt;/h3&gt;

&lt;p&gt;First of all, on the building stage (&lt;code&gt;docker run ...&lt;/code&gt;) you will encounter the following error message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd .; git clone https://github.com/company/bar /go/src/github.com/company/bar
Cloning into &#39;/go/src/github.com/company/bar&#39;...
fatal: could not read Username for &#39;https://github.com&#39;: No such device or address
package github.com/company/bar: exit status 128
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What it does mean, is that your access to github is granted using SSH keys, but &lt;code&gt;git&lt;/code&gt; command, which is invoked by &lt;code&gt;go get&lt;/code&gt;, is trying to clone repository using HTTPS form and you don&amp;rsquo;t have credentials set up.&lt;/p&gt;

&lt;p&gt;Workaround for this is easy, and described in the beginning of this post, so we just have to add this to our Dockerfile right before calling &lt;code&gt;go get&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RUN echo &amp;quot;[url \&amp;quot;git@github.com:\&amp;quot;]\n\tinsteadOf = https://github.com/&amp;quot; &amp;gt;&amp;gt; /root/.gitconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;keys&#34;&gt;Keys&lt;/h3&gt;

&lt;p&gt;The next error you&amp;rsquo;ll see is host key verification error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd .; git clone https://github.com/company/bar /go/src/github.com/company/bar
Cloning into &#39;/go/src/github.com/company/bar&#39;...
Host key verification failed.
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
package github.com/company/bar: exit status 128
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, it&amp;rsquo;s simply because our Docker container doesn&amp;rsquo;t have SSH keys yet. And the right approach is not trivial, so let&amp;rsquo;s go through it.&lt;/p&gt;

&lt;p&gt;First of all, we want every developer or CI to use it&amp;rsquo;s own keys for accessing private repo. If person has access to &lt;code&gt;foo&lt;/code&gt;, she&amp;rsquo;s definitely has an access to &lt;code&gt;bar&lt;/code&gt; and the keys are usually in &lt;code&gt;~/.ssh/id_rsa&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You can&amp;rsquo;t copy keys into container, though.&lt;/strong&gt; Dockerfile&amp;rsquo;s ADD and COPY commands can copy files from the current directory only, so you can&amp;rsquo;t just add &lt;code&gt;ADD ~/.ssh/ /root/ssh&lt;/code&gt; to your Dockerfile. One of the solution is to write wrapper script that will copy private key to local directory and then to the container, but it&amp;rsquo;s still not very safe and elegant solution.&lt;/p&gt;

&lt;p&gt;What we can do, is to mount volume using docker&amp;rsquo;s &lt;code&gt;-v&lt;/code&gt; command line flag. The first approach will be probably to mount the whole &lt;code&gt;~/.ssh&lt;/code&gt; directory, but it&amp;rsquo;s tricky&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker run --name=foo-build -v ~/.ssh:/root/.ssh foo-build&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This command will work as expected on MacOS X (using latest Docker Beta, at least), but not in Linux box. The reason is the files ownership for &lt;code&gt;~/.ssh/config&lt;/code&gt; file. The &lt;code&gt;ssh&lt;/code&gt; (which is invoked by &lt;code&gt;git&lt;/code&gt;, which is invoked by &lt;code&gt;go get&lt;/code&gt;) expects this file to have the same user ownership as a running user. Inside the container the user is &lt;code&gt;root&lt;/code&gt;, but the mounted directory most probably has ovnership of your normal Linux user, say, &lt;code&gt;developer&lt;/code&gt; and inside the container it looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls ~/.ssh/config
-rw-r--r--  1 1000  1000  147 Jun  1 19:20 /root/.ssh/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;making SSH to complain and abort:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Bad owner or permissions on ~/.ssh/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution is to mount only the key and workaround host checking later.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --name=foo-build -v ~/.ssh/id_rsa:/root/.ssh/id_rsa foo-build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Error will be the same, though, but rerunning it with &lt;code&gt;-t&lt;/code&gt; option, we&amp;rsquo;ll see the reason:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --name=foo-build -v ~/.ssh/id_rsa:/root/.ssh/id_rsa -t foo-build
The authenticity of host &#39;github.com (192.30.252.128)&#39; can&#39;t be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we don&amp;rsquo;t want to interact manually with ssh prompt, so we have to find a way to force it. There is an SSH client option for that, called StrictHostChecking.&lt;/p&gt;

&lt;h3 id=&#34;stricthostchecking&#34;&gt;StrictHostChecking&lt;/h3&gt;

&lt;p&gt;Typically, you have file named &lt;code&gt;~/.ssh/known_hosts&lt;/code&gt;, which holds information about, well, known hosts. But in our container, there is no such file, so we have to use the client option to supress those checks. The easiest way to do this is to put this option into the &lt;code&gt;~/.ssh/config&lt;/code&gt; file - yes, the one we had ownership problems with.&lt;/p&gt;

&lt;p&gt;But, we only need one option, so it&amp;rsquo;s ok to create this file on the fly inside the container. Add to Dockerfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RUN mkdir /root/.ssh &amp;amp;&amp;amp; echo &amp;quot;StrictHostKeyChecking no &amp;quot; &amp;gt; /root/.ssh/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rerun the &lt;code&gt;docker run&lt;/code&gt; step and you&amp;rsquo;ll finally have success!&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;The final Dockerfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM golang:1.6

RUN echo &amp;quot;[url \&amp;quot;git@github.com:\&amp;quot;]\n\tinsteadOf = https://github.com/&amp;quot; &amp;gt;&amp;gt; /root/.gitconfig
RUN mkdir /root/.ssh &amp;amp;&amp;amp; echo &amp;quot;StrictHostKeyChecking no &amp;quot; &amp;gt; /root/.ssh/config
ADD .  /go/src/github.com/company/foo
CMD cd /go/src/github.com/company/foo &amp;amp;&amp;amp; go get github.com/company/bar &amp;amp;&amp;amp; go build -o /foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the build steps:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t foo-build .
docker run --name=foo-build -v ~/.ssh/id_rsa:/root/.ssh/id_rsa foo-build
docker cp foo-build:/foo foo
docker rm -f foo-build
docker rmi -f foo-build	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may put those steps to the Makefile or custom build script, and can safely use it locally or in CI or whatever.&lt;/p&gt;

&lt;p&gt;Private SSH key is copied once into the temporary container, used for building, which is removed immediately. Nice and safe solution.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Visualizing Concurrency in Go</title>
      <link>https://divan.github.io/posts/go_concurrency_visualize/</link>
      <pubDate>Sun, 24 Jan 2016 18:31:12 -0300</pubDate>
      
      <guid>https://divan.github.io/posts/go_concurrency_visualize/</guid>
      <description>

&lt;p&gt;&lt;em&gt;If you prefer video over blog posts, here is my talk on this at GopherCon 2016:&lt;/em&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=KyuFeiG3Y60&#34;&gt;https://www.youtube.com/watch?v=KyuFeiG3Y60&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;One of the strongest sides of Go programming language is a built-in concurrency based on &lt;a href=&#34;https://en.wikipedia.org/wiki/Communicating_sequential_processes&#34;&gt;Tony Hoare&amp;rsquo;s CSP&lt;/a&gt; paper. Go is designed with concurrency in mind and allows us to build complex concurrent pipelines. But have you ever wondered - how various concurrency patterns look like?&lt;/p&gt;

&lt;p&gt;Of course, you have. We&amp;rsquo;re all thinking mostly by visualization in one form or another. If I ask you something involving &amp;ldquo;numbers from 1 to 100&amp;rdquo; you will have your own image of the series in your head, even without realizing it. For example, I imagine it as a line going from me with numbers from 1 to 20, then it turns 90 degrees to the right and continues to the 1000+. I recall from very young period of my life that in our kindergarten there were numbers in a cloakroom, written along the wall, and number 20 was exactly at the corner. You probably have your own image of numbers. Another common example is the visual representation of the full year with four seasons - some people see it as a box, other - as a circle.&lt;/p&gt;

&lt;p&gt;Anyway, I want to show you my attempt to visualize common concurrency patterns using Go and WebGL. It more or less represents the way I see  concurrent programs in my head. Would be pretty interesting to hear how much it differs from images in your head. I especially would love to see how Rob Pike or Sameer Ajmani imagine concurrency. I bet I&amp;rsquo;d be quite interesting.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s start with the very basic &amp;ldquo;Hello, Concurrent World&amp;rdquo; example, to get ourselves familiar with the concept of my attempt.&lt;/p&gt;

&lt;h3 id=&#34;hello-concurrent-world&#34;&gt;Hello, Concurrent world&lt;/h3&gt;

&lt;p&gt;The code is quite simple - single channel, single goroutine, one write, one read.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

func main() {
    // create new channel of type int
    ch := make(chan int)

    // start new anonymous goroutine
    go func() {
        // send 42 to channel
        ch &lt;- 42
    }()
    // read from channel
    &lt;-ch
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/hello/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/hello.gif&#34; alt=&#34;Hello, World&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here the blue lines represent goroutines running down through time. Thin blue lines connecting &amp;lsquo;main&amp;rsquo; and &amp;lsquo;go #19&amp;rsquo; are marks for start and stop goroutine, revealing parent-children relation and, finally, red arrow shows us the send/recv action. While it&amp;rsquo;s actually two separate actions, I try to animate as a single event &amp;ldquo;send from A to B&amp;rdquo;. The &amp;ldquo;#19&amp;rdquo; in the goroutine name is the actual goroutine internal ID, obtained from runtime with a trick suggested by Scott Mansfield in &lt;a href=&#34;http://blog.sgmansfield.com/2015/12/goroutine-ids/&#34;&gt;&amp;ldquo;Goroutine IDs&amp;rdquo;&lt;/a&gt; article.&lt;/p&gt;

&lt;h3 id=&#34;timers&#34;&gt;Timers&lt;/h3&gt;

&lt;p&gt;In fact, you can build a simple timer with this approach - create a channel, start goroutine which writes to this channel after given duration and returns this channel to the caller of your func. The caller then blocks on reading from the channel for the exact amount of time. Let&amp;rsquo;s run such timer 24 times and try to visualize it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import &#34;time&#34;

func timer(d time.Duration) &lt;-chan int {
    c := make(chan int)
    go func() {
        time.Sleep(d)
        c &lt;- 1
    }()
    return c
}

func main() {
    for i := 0; i &lt; 24; i++ {
        c := timer(1 * time.Second)
        &lt;-c
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/timers/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/timers.gif&#34; alt=&#34;Recurrent Timers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pretty neat, right? Let&amp;rsquo;s move on.&lt;/p&gt;

&lt;h3 id=&#34;ping-pong&#34;&gt;Ping-pong&lt;/h3&gt;

&lt;p&gt;This nice concurrency example was found in a great talk by googler Sameer Ajmani &lt;a href=&#34;https://talks.golang.org/2013/advconc.slide#1&#34;&gt;&amp;ldquo;Advanced Go Concurrency Patterns&amp;rdquo;&lt;/a&gt;. Of course, this pattern isn&amp;rsquo;t very advanced, but for those who only get themselves familiar with Go concurrency it may look quite fresh and interesting.&lt;/p&gt;

&lt;p&gt;Here we have a channel as a table of the ping-pong game. The ball is an integer variable, and two goroutines-players that &amp;lsquo;hit&amp;rsquo; the ball, increasing its value (hits counter).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import &#34;time&#34;

func main() {
    var Ball int
    table := make(chan int)
    go player(table)
    go player(table)

    table &lt;- Ball
    time.Sleep(1 * time.Second)
    &lt;-table
}

func player(table chan int) {
    for {
        ball := &lt;-table
        ball++
        time.Sleep(100 * time.Millisecond)
        table &lt;- ball
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/pingpong/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/pingpong.gif&#34; alt=&#34;Ping-Pong&#34; /&gt;
At this point I&amp;rsquo;d suggest you to click that &lt;a href=&#34;https://divan.github.io/demos/pingpong/&#34;&gt;link above&lt;/a&gt; to the interactive WebGL animation (Ctrl/Cmd-Click to open it in a new tab) and play around with interactively. You can slowdown animation, speedup and see it in different angles.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s run three players instead of two.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;    go player(table)
    go player(table)
    go player(table)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/pingpong3/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/pingpong3.gif&#34; alt=&#34;Ping-Pong 3&#34; /&gt;
We can see here that each player takes its turn sequentially and you may wonder why is it so. Why we see this strict order in goroutines receiving the ball?&lt;/p&gt;

&lt;p&gt;The answer is because Go runtime holds waiting &lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/chan.go#L34&#34;&gt;FIFO queue for receivers&lt;/a&gt; (goroutines ready to receive on the particular channel), and in our case every player gets ready just after he passed the ball on the table. Let&amp;rsquo;s check it with more complex example and run 100 table tennis players.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;for i := 0; i &lt; 100; i++ {
    go player(table)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/pingpong100/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/pingpong100.gif&#34; alt=&#34;Ping-Pong 100&#34; /&gt;
The FIFO order is now obvious, isn&amp;rsquo;t it? We can spawn a million goroutines (they&amp;rsquo;re cheap), but for our goal that would be overkill.
Let&amp;rsquo;s see something different to play with. For example, common messaging patterns.&lt;/p&gt;

&lt;h3 id=&#34;fan-in&#34;&gt;Fan-In&lt;/h3&gt;

&lt;p&gt;One of the popular patterns in the concurrent world is a so called &lt;em&gt;fan-in&lt;/em&gt; pattern. It&amp;rsquo;s the opposite of the &lt;em&gt;fan-out&lt;/em&gt; pattern, which we will cover later. To be short, fan-in is a function reading from the multiple inputs and multiplexing all into the single channel.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

func producer(ch chan int, d time.Duration) {
    var i int
    for {
        ch &lt;- i
        i++
        time.Sleep(d)
    }
}

func reader(out chan int) {
    for x := range out {
        fmt.Println(x)
    }
}

func main() {
    ch := make(chan int)
    out := make(chan int)
    go producer(ch, 100*time.Millisecond)
    go producer(ch, 250*time.Millisecond)
    go reader(out)
    for i := range ch {
        out &lt;- i
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/fanin/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/fanin.gif&#34; alt=&#34;Fan-In Pattern&#34; /&gt;
As we can see, first &lt;em&gt;producer&lt;/em&gt; generates values each 100 milliseconds, and second one - each 250 milliseconds, but &lt;em&gt;reader&lt;/em&gt; receives values from both producers immediately. Effectively, multiplexing happens in a range loop in &lt;em&gt;main&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;workers&#34;&gt;Workers&lt;/h3&gt;

&lt;p&gt;The opposite pattern to &lt;em&gt;fan-in&lt;/em&gt; is a &lt;em&gt;fan-out&lt;/em&gt; or &lt;em&gt;workers&lt;/em&gt; pattern. Multiple goroutines can read from a single channel, distributing an amount of work between CPU cores, hence the &lt;em&gt;workers&lt;/em&gt; name. In Go, this pattern is easy to implement - just start a number of goroutines with channel as parameter, and just send values to that channel - distributing and multiplexing will be done by Go runtime, automagically :)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;fmt&#34;
    &#34;sync&#34;
    &#34;time&#34;
)

func worker(tasksCh &lt;-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        task, ok := &lt;-tasksCh
        if !ok {
            return
        }
        d := time.Duration(task) * time.Millisecond
        time.Sleep(d)
        fmt.Println(&#34;processing task&#34;, task)
    }
}

func pool(wg *sync.WaitGroup, workers, tasks int) {
    tasksCh := make(chan int)

    for i := 0; i &lt; workers; i++ {
        go worker(tasksCh, wg)
    }

    for i := 0; i &lt; tasks; i++ {
        tasksCh &lt;- i
    }

    close(tasksCh)
}

func main() {
    var wg sync.WaitGroup
    wg.Add(36)
    go pool(&amp;wg, 36, 50)
    wg.Wait()
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/workers/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/workers.gif&#34; alt=&#34;Workers&#34; /&gt;
One thing worth to note here: the parallelism. As you can see, all goroutines &amp;lsquo;run&amp;rsquo; in parallel, waiting for channel to give them &amp;lsquo;work&amp;rsquo; to do. Given the animation above, it&amp;rsquo;s easy to spot that goroutines receive their work almost immediately one after another. Unfortunately, this animation doesn&amp;rsquo;t show in color where goroutine really does work or just waits for input, but this exact animation was recorded with GOMAXPROCS=4, so only 4 goroutines effectively run in parallel. We will get to this subject shortly.&lt;/p&gt;

&lt;p&gt;For now, let&amp;rsquo;s do something more complex, and start workers that have their own workers (subworkers).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;fmt&#34;
    &#34;sync&#34;
    &#34;time&#34;
)

const (
    WORKERS    = 5
    SUBWORKERS = 3
    TASKS      = 20
    SUBTASKS   = 10
)

func subworker(subtasks chan int) {
    for {
        task, ok := &lt;-subtasks
        if !ok {
            return
        }
        time.Sleep(time.Duration(task) * time.Millisecond)
        fmt.Println(task)
    }
}

func worker(tasks &lt;-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        task, ok := &lt;-tasks
        if !ok {
            return
        }

        subtasks := make(chan int)
        for i := 0; i &lt; SUBWORKERS; i++ {
            go subworker(subtasks)
        }
        for i := 0; i &lt; SUBTASKS; i++ {
            task1 := task * i
            subtasks &lt;- task1
        }
        close(subtasks)
    }
}

func main() {
    var wg sync.WaitGroup
    wg.Add(WORKERS)
    tasks := make(chan int)

    for i := 0; i &lt; WORKERS; i++ {
        go worker(tasks, &amp;wg)
    }

    for i := 0; i &lt; TASKS; i++ {
        tasks &lt;- i
    }

    close(tasks)
    wg.Wait()
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/workers2/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/workers2.gif&#34; alt=&#34;Workers of workers&#34; /&gt;
Nice. Of course, we can set number of workers and subworkers to much higher values, but I tried to make animations clear and understandable.&lt;/p&gt;

&lt;p&gt;There are even cooler fan-out patterns do exist, like the dynamic amount of workers/subworkers, with sending channels over channels, but the idea of fan-out should be clear for now.&lt;/p&gt;

&lt;h3 id=&#34;servers&#34;&gt;Servers&lt;/h3&gt;

&lt;p&gt;Next common pattern is similar to fan-out, but with goroutines spawned for the short period of time, just to accomplish some task. It&amp;rsquo;s typically used for implementing servers - create a listener, run accept() in a loop and start goroutine for each accepted connection. It&amp;rsquo;s very expressive and allows to implement server handlers as simple as possible. Take a look at this simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import &#34;net&#34;

func handler(c net.Conn) {
    c.Write([]byte(&#34;ok&#34;))
    c.Close()
}

func main() {
    l, err := net.Listen(&#34;tcp&#34;, &#34;:5000&#34;)
    if err != nil {
        panic(err)
    }
    for {
        c, err := l.Accept()
        if err != nil {
            continue
        }
        go handler(c)
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/servers/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/servers.gif&#34; alt=&#34;Servers&#34; /&gt;
It&amp;rsquo;s not very interesting - it seems there is nothing happens in terms of concurrency. Of course, under the hood there is a ton of complexity, which is deliberately hidden from us. &lt;a href=&#34;https://www.youtube.com/watch?v=rFejpH_tAHM&#34;&gt;&amp;ldquo;Simplicity is complicated&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s go back to concurrency and add some interaction to our server. Let&amp;rsquo;s say, each handler wants to write asynchronously to the logger. Logger itself, in our example, is a separate goroutine which does the job.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;fmt&#34;
    &#34;net&#34;
    &#34;time&#34;
)

func handler(c net.Conn, ch chan string) {
    ch &lt;- c.RemoteAddr().String()
    c.Write([]byte(&#34;ok&#34;))
    c.Close()
}

func logger(ch chan string) {
    for {
        fmt.Println(&lt;-ch)
    }
}

func server(l net.Listener, ch chan string) {
    for {
        c, err := l.Accept()
        if err != nil {
            continue
        }
        go handler(c, ch)
    }
}

func main() {
    l, err := net.Listen(&#34;tcp&#34;, &#34;:5000&#34;)
    if err != nil {
        panic(err)
    }
    ch := make(chan string)
    go logger(ch)
    go server(l, ch)
    time.Sleep(10 * time.Second)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/servers2/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/servers2.gif&#34; alt=&#34;Servers 2&#34; /&gt;
Quite demonstrative, isn&amp;rsquo;t it? But it&amp;rsquo;s easy to see that our &lt;em&gt;logger&lt;/em&gt; goroutine can quickly become a bottleneck if the number of requests increase and logging action take some time (preparing and encoding data, for example). We can use an already known fan-out pattern. Let&amp;rsquo;s do it.&lt;/p&gt;

&lt;h3 id=&#34;server-worker&#34;&gt;Server + Worker&lt;/h3&gt;

&lt;p&gt;Server with worker example is a bit advanced version of the logger. It not only does some work but sends the result of its work back to the pool using &lt;em&gt;results&lt;/em&gt; channel. Not a big deal, but it extends our logger example to something more practical.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see the code and animation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;net&#34;
    &#34;time&#34;
)

func handler(c net.Conn, ch chan string) {
    addr := c.RemoteAddr().String()
    ch &lt;- addr
    time.Sleep(100 * time.Millisecond)
    c.Write([]byte(&#34;ok&#34;))
    c.Close()
}

func logger(wch chan int, results chan int) {
    for {
        data := &lt;-wch
        data++
        results &lt;- data
    }
}

func parse(results chan int) {
    for {
        &lt;-results
    }
}

func pool(ch chan string, n int) {
    wch := make(chan int)
    results := make(chan int)
    for i := 0; i &lt; n; i++ {
        go logger(wch, results)
    }
    go parse(results)
    for {
        addr := &lt;-ch
        l := len(addr)
        wch &lt;- l
    }
}

func server(l net.Listener, ch chan string) {
    for {
        c, err := l.Accept()
        if err != nil {
            continue
        }
        go handler(c, ch)
    }
}

func main() {
    l, err := net.Listen(&#34;tcp&#34;, &#34;:5000&#34;)
    if err != nil {
        panic(err)
    }
    ch := make(chan string)
    go pool(ch, 4)
    go server(l, ch)
    time.Sleep(10 * time.Second)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/servers3/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/servers3.gif&#34; alt=&#34;Server + Worker&#34; /&gt;
We distributed work between 4 goroutines, effectively improving the throughput of the logger, but from this animation, we can see that logger still may be the source of problems. Thousands of connections converge in a single channel before being distributed and it may result in a logger being bottleneck again. But, of course, it will happen on much higher loads.&lt;/p&gt;

&lt;h3 id=&#34;concurrent-prime-sieve&#34;&gt;Concurrent Prime Sieve&lt;/h3&gt;

&lt;p&gt;Enough fan-in/fan-out fun. Let&amp;rsquo;s see more sophisticated concurrency algorithms. One of my favorite examples is a Concurrent Prime Sieve, found in &lt;a href=&#34;https://talks.golang.org/2012/concurrency.slide&#34;&gt;&amp;ldquo;Go Concurrency Patterns&amp;rdquo;&lt;/a&gt; talk. Prime Sieve, or &lt;a href=&#34;https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&#34;&gt;Sieve of Eratosthenes&lt;/a&gt; is an ancient algorithm for finding prime number up to the given limit. It works by eliminating multiples of all primes in a sequential manner. Naive algorithm is not really efficient, especially on multicore machines.&lt;/p&gt;

&lt;p&gt;The concurrent variant of this algorithm uses goroutines for filtering numbers - one goroutine per every prime discovered, and channels for sending numbers from the generator to filters. When prime is found, it&amp;rsquo;s being sent via the channel to the &lt;em&gt;main&lt;/em&gt; for output. Of course, this algorithm is also not very efficient, especially if you want to find large primes and look for the lowest Big O complexity, but I find it extremely elegant.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// A concurrent prime sieve
package main

import &#34;fmt&#34;

// Send the sequence 2, 3, 4, ... to channel &#39;ch&#39;.
func Generate(ch chan&lt;- int) {
    for i := 2; ; i++ {
        ch &lt;- i // Send &#39;i&#39; to channel &#39;ch&#39;.
    }
}

// Copy the values from channel &#39;in&#39; to channel &#39;out&#39;,
// removing those divisible by &#39;prime&#39;.
func Filter(in &lt;-chan int, out chan&lt;- int, prime int) {
    for {
        i := &lt;-in // Receive value from &#39;in&#39;.
        if i%prime != 0 {
            out &lt;- i // Send &#39;i&#39; to &#39;out&#39;.
        }
    }
}

// The prime sieve: Daisy-chain Filter processes.
func main() {
    ch := make(chan int) // Create a new channel.
    go Generate(ch)      // Launch Generate goroutine.
    for i := 0; i &lt; 10; i++ {
        prime := &lt;-ch
        fmt.Println(prime)
        ch1 := make(chan int)
        go Filter(ch, ch1, prime)
        ch = ch1
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/primesieve/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/primesieve.gif&#34; alt=&#34;PrimeSieve&#34; /&gt;
Feel free to play with this animation in interactive mode. I like how illustrative it is - it really can help understand this algorithm better. The &lt;em&gt;generate&lt;/em&gt; goroutine emits every integer number, starting from 2, and each new goroutine filters out only specific prime multiples - 2, 3, 5, 7&amp;hellip;, sending first found prime to &lt;em&gt;main&lt;/em&gt;. If you rotate it to see from the top, you&amp;rsquo;ll see all numbers being sent from goroutines to main are prime numbers. Beautiful algorithm, especially in 3D.&lt;/p&gt;

&lt;h3 id=&#34;gomaxprocs&#34;&gt;GOMAXPROCS&lt;/h3&gt;

&lt;p&gt;Now, let&amp;rsquo;s go back to our workers example. Remember, I told that it was run with GOMAXPROCS=4? That&amp;rsquo;s because all these animations are not art work, they are real traces of real programs.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s refresh our memory on what &lt;a href=&#34;https://golang.org/pkg/runtime/#GOMAXPROCS&#34;&gt;GOMAXPROCS&lt;/a&gt; is.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CPU means logical CPU, of course. I modified workers example a bit to make a real work (not just sleep) and use real CPU time. Then I ran the code without any modification except setting different GOMAXPROCS value. The Linux box had 2 CPUs with 12 cores each, resulting in 24 cores.&lt;/p&gt;

&lt;p&gt;So, the first run demonstrates the program running on 1 core, and second - using the power of all 24 cores availiable.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/gomaxprocs1/&#34;&gt;WebGL animation - 1&lt;/a&gt; | &lt;a href=&#34;https://divan.github.io/demos/gomaxprocs24/&#34;&gt;WebGL animation - 24&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/gomaxprocs1.gif&#34; alt=&#34;GOMAXPROCS1&#34; /&gt; &lt;img src=&#34;https://divan.github.io/demos/gifs/gomaxprocs24.gif&#34; alt=&#34;GOMAXPROCS24&#34; /&gt;
The time speed in these animations are different (I wanted all animations to fit the same time/height), so the difference is obvious. With GOMAXPROCS=1, next worker start real work only after previous has finish it&amp;rsquo;s work. With GOMAXPROCS=24 the speedup is huge, and overhead for multiplexing is negligible.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important to understand, though, that increasing GOMAXPROCS not always boosts performance, and there cases when it actually makes it worse.&lt;/p&gt;

&lt;h3 id=&#34;goroutines-leak&#34;&gt;Goroutines leak&lt;/h3&gt;

&lt;p&gt;What else we can demonstrate from concurrent things in Go? The one thing that comes to my mind is a goroutines leak. A leak can happen, for example, if you &lt;a href=&#34;http://openmymind.net/Leaking-Goroutines/&#34;&gt;start goroutine but it falls out of scope&lt;/a&gt;. Or you simply forget to add finish condition, and run a for {} loop.&lt;/p&gt;

&lt;p&gt;First time I&amp;rsquo;ve encountered goroutine leak in my code, the scary image appeared in my head and I wrote &lt;a href=&#34;https://github.com/divan/expvarmon&#34;&gt;expvarmon&lt;/a&gt; next weekend. And now I can visualize that scary image with WebGL.&lt;/p&gt;

&lt;p&gt;Take a look:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/leak/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/leak.gif&#34; alt=&#34;Leak&#34; /&gt;
I feel pain even simply by looking at this :) All those lines are wasted resources and a ticking bomb for your program.&lt;/p&gt;

&lt;h3 id=&#34;parallelism-is-not-concurrency&#34;&gt;Parallelism is not Concurrency&lt;/h3&gt;

&lt;p&gt;The last thing I want to illustrate is a difference between parallelism and concurrency. This topic is &lt;a href=&#34;https://existentialtype.wordpress.com/2011/03/17/parallelism-is-not-concurrency/&#34;&gt;well&lt;/a&gt; &lt;a href=&#34;https://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/&#34;&gt;covered&lt;/a&gt;, and there is a &lt;a href=&#34;https://www.youtube.com/watch?v=cN_DpYBzKso&#34;&gt;great talk by Rob Pike&lt;/a&gt; on the subject. One of the #mustwatch videos, really.&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;center&gt;
		&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;760&#34; height=&#34;457&#34; src=&#34;http://www.youtube.com/embed/cN_DpYBzKso&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
		&lt;/iframe&gt;
	&lt;/center&gt;
&lt;/div&gt;


&lt;p&gt;To be short,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Parallelism is simply running things in parallel.&lt;/p&gt;

&lt;p&gt;Concurrency is a way to structure your program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thus, the concurrent program may or may not be parallel, these concepts are somehow orthogonal. We have seen this earlier in a demonstration of GOMAXPROCS setting effects.&lt;/p&gt;

&lt;p&gt;I can repeat all those linked articles and talks, but a picture is worth a thousand words. What I can do here is to visualize the difference.
So, this is parallelism. Many things running in parallel.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/parallelism1/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/parallelism1.gif&#34; alt=&#34;Parallelism 1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this is also parallelism:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/parallelism2/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/parallelism2.gif&#34; alt=&#34;Parallelism 2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But this is concurrency:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/demos/gifs/primesieve.gif&#34; alt=&#34;PrimeSieve&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/demos/gifs/workers2.gif&#34; alt=&#34;Workers of workers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this is also concurrency:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/demos/gifs/pingpong100.gif&#34; alt=&#34;Ping-Pong 100&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-it-was-made&#34;&gt;How it was made&lt;/h3&gt;

&lt;p&gt;To create these animations, I wrote two programs: &lt;em&gt;gotracer&lt;/em&gt; and &lt;em&gt;gothree.js&lt;/em&gt; library.
First, gotracer does the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;parse AST tree of Go program and insert special commands with output on concurrency related events - start/stop goroutine, create a channel, send/receive to/from a channel.&lt;/li&gt;
&lt;li&gt;run generated program&lt;/li&gt;
&lt;li&gt;analyze this special output and produce JSON with the description of events and timestamps.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example of the resulting JSON:
&lt;img src=&#34;https://divan.github.io/images/sshot_json.png&#34; alt=&#34;JSON sample&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next, gothree.js uses the power of an amazing &lt;a href=&#34;http://threejs.org/&#34;&gt;Three.js&lt;/a&gt; library to draw 3D lines and objects using WebGL. Little wrapper to fit into single html page - and there it is.&lt;/p&gt;

&lt;p&gt;This approach, though, is super limited. I have to accurately choose examples, rename channels and goroutines to make more or less complex code to produce a correct trace. With this approach, there is no easy way to correllate channels between goroutines if they have different names. Not to mention channels sent over channels of type chan. There are also huge issues with timing - output to stdout can take more time than sending value, so in some cases I had to place time.Sleep(some amount of milliseconds) to get proper animation.&lt;/p&gt;

&lt;p&gt;Basically, that is a reason why I&amp;rsquo;m not open-sourcing the code yet. I&amp;rsquo;m playing with Dmitry Vyukov&amp;rsquo;s &lt;a href=&#34;https://golang.org/cmd/trace/&#34;&gt;execution tracer&lt;/a&gt;, it seems to provide good level of details of events, but do not contain info on which values are being sent. Maybe there are better ways to achieve the desired goal. Write me in twiter or in comments here, if you have ideas. It would be super great to extend this two-weekends tool to be a real debugging/tracing instrument suitable for any Go program.&lt;/p&gt;

&lt;p&gt;I also would be happy to visualize more interesting concurrent algorithms and patterns not listed here. Feel free to write ones in the comments.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;

&lt;p&gt;UPD: This tool is available at &lt;a href=&#34;https://github.com/divan/gotrace&#34;&gt;github.com/divan/gotrace&lt;/a&gt; and using Go Execution Tracer and patched runtime to generate trace.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to complain about Go</title>
      <link>https://divan.github.io/posts/go_complain_howto/</link>
      <pubDate>Mon, 14 Dec 2015 08:36:54 -0300</pubDate>
      
      <guid>https://divan.github.io/posts/go_complain_howto/</guid>
      <description>

&lt;p&gt;Over the years of existence of Go programming language, the articles with its critique was always popular, bringing a lot of discussion from both sides. Recently, &lt;a href=&#34;https://github.com/ksimka&#34;&gt;Maksim Kochkin&lt;/a&gt; even created GitHub repo with &lt;a href=&#34;https://github.com/ksimka/go-is-not-good&#34;&gt;curated list&lt;/a&gt; of articles complaining about golang&amp;rsquo;s imperfection.&lt;/p&gt;

&lt;p&gt;So, is it true that ranting about Go flaws is a trend nowadays? With carefully gathered links in the repository above, we can check this! :) Unfortunately, there are only 17 articles in the list, which is a bit disappointing because it&amp;rsquo;s not enough for fine statistical analysis, but we can use this anyway.&lt;/p&gt;

&lt;p&gt;Here is a trending line for the &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1qKFykmm0yapLq1FKuouvqVZkWo-HHCfJnrTikqRoAfs/edit#gid=1956718702&#34;&gt;number of Go complaints written per year&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/go_rants_trend.png&#34; alt=&#34;Trending&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The trending is obvious - from one in 2009 to five in 2015. Hopefully, the next 2016 year will continue this trend line.&lt;/p&gt;

&lt;p&gt;But what I liked most about this list - is a brief resume on the major authors&amp;rsquo; points. We can measure the popularity of users&amp;rsquo; complaints by counting aggregated points. Again, let&amp;rsquo;s do it in our Google Sheet document, which is written in Google, and probably involves a lot of production Go code to let us enjoy this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/go_rants_top.png&#34; alt=&#34;Trending&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let me write again the top-5 winners:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;error handling / no exceptions&lt;/li&gt;
&lt;li&gt;no generics&lt;/li&gt;
&lt;li&gt;stuck in 70&amp;rsquo;s&lt;/li&gt;
&lt;li&gt;no OOP&lt;/li&gt;
&lt;li&gt;too opinionated&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Again, it&amp;rsquo;s a bit disappointing that absolute winner (&lt;em&gt;&amp;ldquo;error handling&amp;rdquo;&lt;/em&gt;) is mentioned only 7 times. Many thousands of people are using Go every day and only 7 put their major complaint into words in the form of a blog post? This flank definitely needs more support.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t like Go, you may contribute here. Especially if you tried Go before you started complaining about its design. But how to start the  article to make a proper effect? Take a look at these 5 top complaints and choose on which one you want elaborate.&lt;/p&gt;

&lt;p&gt;Keep in mind, &lt;em&gt;&amp;ldquo;error handling&amp;rdquo;&lt;/em&gt; and &lt;em&gt;&amp;ldquo;no generics&amp;rdquo;&lt;/em&gt; are absolute winners - you have absolutely no excuse not to add them to your list. Next, be careful with &lt;em&gt;&amp;ldquo;no OOP&amp;rdquo;&lt;/em&gt; because it&amp;rsquo;s easy to attack by quoting Alan Kay. &lt;em&gt;&amp;ldquo;Too opinionated&amp;rdquo;&lt;/em&gt; is a good choice, but should be carefully argued so you don&amp;rsquo;t look like a grouchy geek rather than a thoughtful hacker. &lt;em&gt;&amp;ldquo;Stuck in 70&amp;rsquo;s&amp;rdquo;&lt;/em&gt; works best if you want not only complain about Go but popularize another modern and objectively good programming language.&lt;/p&gt;

&lt;p&gt;But what if it&amp;rsquo;s not enough? There are 41 more other complaints scored 1 or 2 in the list, not including ones you can make up on your own! So, to help you make a choice, here are some rules and guidelines on how to properly complain about Go, depending on you previous background and experience.&lt;/p&gt;

&lt;p&gt;For example, if you come from&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;python&#34;&gt;&amp;hellip;Python&lt;/h2&gt;

&lt;p&gt;We all love Python, so the attack vector should be on the maturity and abundance of libraries. NumPy is a must have point - Go still don&amp;rsquo;t have a scientific library of that quality. Not sure how SpaceX is able to use Go without one, but whatever, NumPy sells well.&lt;/p&gt;

&lt;p&gt;Try not to mention mature libraries like Twisted, Requests and various solutions for solving the 10K problem. Just don&amp;rsquo;t mention it. Instead, try to disprove relatively high memory usage in Python. For example, you can say that Python memory usage after goroutines leakage is competitive with Go. Someone from Mozilla &lt;a href=&#34;https://docs.google.com/presentation/d/1LO_WI3N-3p2Wp9PDWyv5B6EGFZ8XTOTNJ7Hd40WOUHo/mobilepresent?pli=1&amp;amp;slide=id.g70b0035b2_1_119&#34;&gt;said this&lt;/a&gt;, so can you.&lt;/p&gt;

&lt;p&gt;As a bonus, mention that Go slice indexing doesn&amp;rsquo;t have convenient -1 index. &lt;em&gt;&amp;ldquo;Is compiled&amp;rdquo;&lt;/em&gt; flaw also works here, without any explanation. Just because.&lt;/p&gt;

&lt;h2 id=&#34;c&#34;&gt;&amp;hellip;C++&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re C++ developer, you are in the most vulnerable position, because Go was created as an answer to the C++ problems. Which easily can be muted or presented as powerful features.&lt;/p&gt;

&lt;p&gt;Start by demonizing GC. Everyone knows that Garbage Collection is an evil and every CPU tact matters. Even if you write simple REST-backend in C++ and it takes 6 months of your life to accomplish it - you still have speed and no-GC blissfulness. Stick with that.&lt;/p&gt;

&lt;p&gt;As a logical continuation - tell that Go is not good for embedded. Don&amp;rsquo;t mention that authors explicitly said that it was never meant as a language for embedded. It&amp;rsquo;s a great point anyway. And if your commenters will send you links to &lt;a href=&#34;http://embd.kidoman.io&#34;&gt;Embd&lt;/a&gt;, &lt;a href=&#34;http://gobot.io&#34;&gt;Gobot&lt;/a&gt; or &lt;a href=&#34;https://github.com/golang/mobile&#34;&gt;gomobile&lt;/a&gt;, just say that it&amp;rsquo;s not True Embedded or just disable comments.&lt;/p&gt;

&lt;p&gt;And, of course, all rants about how Go restricting you from shooting yourself in the foot are also great here. Go doesn&amp;rsquo;t make you feel clever than your coworker that bangs his head against the wall trying to understand your code. Why do you need such a language after all?&lt;/p&gt;

&lt;h2 id=&#34;rust&#34;&gt;&amp;hellip;Rust&lt;/h2&gt;

&lt;p&gt;Despite the fact that there aren&amp;rsquo;t many people in the wild who can claim &amp;ldquo;background in Rust&amp;rdquo;, there are still a bunch of people from C++ background who are totally in love with Rust. They didn&amp;rsquo;t try it in production or even for pet projects, but that&amp;rsquo;s not important. Pure love doesn&amp;rsquo;t need logic. So, many points valid for C++ developers will work for you also. Don&amp;rsquo;t forget &lt;em&gt;&amp;ldquo;zero-cost abstraction&amp;rdquo;&lt;/em&gt; phrase after mentioning how evil GC is.&lt;/p&gt;

&lt;p&gt;Cargo is considered to be a good solution for dependency management, so attack this side of Go aggressively. No chance to lose here. Also, your key points should be Go&amp;rsquo;s simple type system and lack of pattern matching. Basically, everything that differs in Go from Rust will work here. And that&amp;rsquo;s a lot, so you can write a solid longread. Or two.&lt;/p&gt;

&lt;h2 id=&#34;java&#34;&gt;&amp;hellip;Java&lt;/h2&gt;

&lt;p&gt;After mentioning generics and exceptions, punch them in the guts and smash them by comparing Java&amp;rsquo;s IDE with Go&amp;rsquo;s IDE. Of course, there is no Go IDE, because Go is too simple to require one, but it&amp;rsquo;s bad also. Double kick. It&amp;rsquo;s &amp;ldquo;advanced&amp;rdquo; vs &amp;ldquo;primitive&amp;rdquo; and you&amp;rsquo;re a winner here.&lt;/p&gt;

&lt;p&gt;Next, write about the lack of good debugger (integrated into IDE, of course). How can someone write even simple code without a debugger? Don&amp;rsquo;t ask if you really need debugger in Go that much as you need it in Java and why. Stay away from this subject, it&amp;rsquo;s slippery.&lt;/p&gt;

&lt;p&gt;And the whole range of &amp;lsquo;features&amp;rsquo; that you can use to make people understand why Go is bad - from lack of JVM to &lt;em&gt;&amp;ldquo;lack of basic data structures&amp;rdquo;&lt;/em&gt;. Take your time and improvise while your IDE starts.&lt;/p&gt;

&lt;h2 id=&#34;ruby&#34;&gt;&amp;hellip;Ruby&lt;/h2&gt;

&lt;p&gt;If you come from Ruby and don&amp;rsquo;t really like Go, I probably won&amp;rsquo;t help you. Go is quite popular in Ruby community and many Ruby developers, being non-arrogant and pragmatic, fall into Go pretty easily, so you&amp;rsquo;re in trouble. Even Basecamp, the guys that made Ruby on Rails, &lt;a href=&#34;https://signalvnoise.com/posts/3897-go-at-basecamp&#34;&gt;love Go&lt;/a&gt; and use it inside. Sorry.&lt;/p&gt;

&lt;h2 id=&#34;d&#34;&gt;&amp;hellip;D&lt;/h2&gt;

&lt;p&gt;Without any doubts, your main argument (after generics and exceptions, of course) should be the name of Google. It&amp;rsquo;s pretty much obvious that popularity of Go is simply a result of a huge money support by Google. Of course, Google pays people a lot to write articles about Go and to organize conferences and meetups. They are so rich, that next year Go community will have &lt;a href=&#34;https://github.com/golang/go/wiki/Conferences&#34;&gt;6 international conferences&lt;/a&gt; including one in &lt;a href=&#34;http://www.gophercon.ae/&#34;&gt;Dubai&lt;/a&gt;! When D have a company that can do the same for D, the world will understand that Go&amp;rsquo;s popularity is a fake.&lt;/p&gt;

&lt;p&gt;Also, Go is not a real system programming language. You can&amp;rsquo;t write your own memory allocator with Go. So switch to D. Please.&lt;/p&gt;

&lt;h2 id=&#34;perl&#34;&gt;&amp;hellip;Perl&lt;/h2&gt;

&lt;p&gt;Emm..&lt;/p&gt;

&lt;h2 id=&#34;c-1&#34;&gt;&amp;hellip;C#&lt;/h2&gt;

&lt;p&gt;Probably the best strategy here is to attack the simplicity of Go. Simplicity equals primitivity, everyone knows in MS world. Also Go is made by Google, not by MS, so it&amp;rsquo;s doomed. There are so many good solutions for modern programming language theory you learn in the college course of C#! But poor people behind Go just are not aware of them. Don&amp;rsquo;t hesitate to teach them. You can&amp;rsquo;t do pretty much anything with a language that primitive as Go.&lt;/p&gt;

&lt;p&gt;Also, mention the most relevant things - no Visual Studio support (&lt;a href=&#34;https://github.com/microsoft/vscode-go&#34;&gt;Visual Studio Code&amp;rsquo;s Go plugin&lt;/a&gt; doesn&amp;rsquo;t count). No debugger in IDE, of course. And no DirectX support, that&amp;rsquo;s important.&lt;/p&gt;

&lt;h2 id=&#34;haskell&#34;&gt;&amp;hellip;Haskell&lt;/h2&gt;

&lt;p&gt;If you come from Haskell, I shouldn&amp;rsquo;t give you any advice. You already must be a professional in mocking Go. It&amp;rsquo;s in Haskell 101 course. New Haskell books contain special chapter &amp;ldquo;How to laugh on Go&amp;rdquo;, after all.&lt;/p&gt;

&lt;p&gt;Even if you &lt;a href=&#34;https://honza.ca/2015/11/language-choice&#34;&gt;intuitively understand&lt;/a&gt; that Go is way more practical than Haskell and entry barrier really matters - keep insisting that it has &amp;ldquo;objectively poor design&amp;rdquo;. Because everyone knows which language has objectively good design.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I hope this article will find its readers. In 2016, we need more articles with rants on Go - at least 6 to keep the trend. Some of the articles in the list above written by students and schoolboys, so if you just started CS class and don&amp;rsquo;t have any real-life experience - don&amp;rsquo;t hesitate to tell the world how bad Go is.&lt;/p&gt;

&lt;p&gt;After all, the viral effect of the articles with criticism is well known - colleagues and managers send you the link as a prove that you shouldn&amp;rsquo;t use Go in production, without even reading or analyzing its content. The title is usually enough, so don&amp;rsquo;t be afraid.&lt;/p&gt;

&lt;p&gt;Or.. you can just write some good code in the language that works best for your case.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Integration testing in Go using Docker</title>
      <link>https://divan.github.io/posts/integration_testing/</link>
      <pubDate>Mon, 07 Dec 2015 08:36:54 -0700</pubDate>
      
      <guid>https://divan.github.io/posts/integration_testing/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Note: this post was originally written for the &lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/introduction/&#34;&gt;Go Advent 2015&lt;/a&gt; series, but I discovered that a post with almost exactly the same subject (and even similar code!) already planned :) That&amp;rsquo;s amazing.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Golang is often used for writing microservices and various backends. Often these type of software do some computation, read/write data on external storage and expose it&amp;rsquo;s API via http handlers. All this functionality is remarkably easy to implement in Go and, especially if you&amp;rsquo;re creating &lt;a href=&#34;http://12factor.net&#34;&gt;12factor&lt;/a&gt;-compatible app, Go is your friend here.&lt;/p&gt;

&lt;p&gt;This functionality is also easy to test using built-in Go testing tooling. But here&amp;rsquo;s the catch - unit testing or &lt;em&gt;small tests&lt;/em&gt; doesn&amp;rsquo;t guarantee that your service is working correctly. Even if you simply want to test your HTTP response codes, you have to inject dependencies first and connect your code to the external resources or storage. At this point you&amp;rsquo;ll probably realize you need to write a proper integration test, which include not only your code but all dependent resources as well.&lt;/p&gt;

&lt;p&gt;But, how to do this without inventing your own scripts and harness code for mocking and starting services? How to make it as easy to use as a normal &amp;lsquo;go test&amp;rsquo; workflow? How to deal with setting up migrations and schemas for you databases? Finally, how to make it cross-platform, so you can easily run those tests on your Macbook as well as in your CI node?&lt;/p&gt;

&lt;p&gt;Let me show one of the possible solutions I use for a number of services for quite a long time. It leverages the power of &lt;a href=&#34;https://www.docker.com&#34;&gt;Docker&lt;/a&gt; isolation and comfort of go test tooling, and thus very easy to use and, with little efforts, gives you truly cross-platform integration testing.&lt;/p&gt;

&lt;p&gt;As an example I&amp;rsquo;ll take simple go-based webservice, which is often may be sufficient for REST-backends:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;REST-service based on &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;gin&lt;/a&gt; framework&lt;/li&gt;
&lt;li&gt;data storage - external MySQL database&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bitbucket.org/liamstask/goose/&#34;&gt;goose&lt;/a&gt; tool for migrations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker&#34;&gt;Docker&lt;/h2&gt;

&lt;p&gt;So, yes, we will use &lt;a href=&#34;https://www.docker.com&#34;&gt;Docker&lt;/a&gt; to handle all external dependencies (MySQL database in our case), and that&amp;rsquo;s exactly the case where Docker shines. Nowadays internet is &lt;a href=&#34;http://ctankersley.com/2014/09/30/docker-a-misunderstood-tool/&#34;&gt;full&lt;/a&gt; of &lt;a href=&#34;http://www.rkn.io/2014/09/26/no-silver-bullets/&#34;&gt;articles&lt;/a&gt; and &lt;a href=&#34;https://speakerdeck.com/rjschwei/docker-not-a-silver-bullet&#34;&gt;talks&lt;/a&gt; telling that Docker is not a &amp;lsquo;silver bullet&amp;rsquo;, and &lt;a href=&#34;https://valdhaus.co/writings/docker-misconceptions/&#34;&gt;putting&lt;/a&gt; a &lt;a href=&#34;http://sirupsen.com/production-docker/&#34;&gt;lot of criticism&lt;/a&gt; on many docker use cases. Of course, they&amp;rsquo;re absolutely right and many of their points are valid, but in this particular case it&amp;rsquo;s exactly the case where you should use Docker. It gives us everything we need - repeatability, isolation, speed, and portability.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start by creating &lt;a href=&#34;http://docs.docker.com/engine/reference/builder/&#34;&gt;Dockerfile&lt;/a&gt; for our dependency service - MySQL database. Normally you would use official mysql docker image, but we have to wind up migrations with goose, so we&amp;rsquo;d better off creating our custom MySQL debian image:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;dockerfile&#34;&gt;FROM debian

ENV DEBIAN_FRONTEND noninteractive
RUN apt-get update
RUN apt-get install -y mysql-server

RUN sed -i -es/^bind-address\s*=\s*127.0.0.1/bind-address = 0.0.0.0/ /etc/mysql/my.cnf

RUN apt-get install -y golang git ca-certificates gcc
ENV GOPATH /root
RUN go get bitbucket.org/liamstask/goose/cmd/goose

ADD. /db
RUN \
service mysql start &amp;&amp; \
sleep 10 &amp;&amp; \
while true; do mysql -e SELECT 1 &amp;&gt; /dev/null; [ $? -eq 0 ] &amp;&amp; break; echo -n &#34;.&#34;; sleep 1; done &amp;&amp; \
mysql -e GRANT ALL ON *.* to &#39;root&#39;@&#39;%&#39;; FLUSH PRIVILEGES; &amp;&amp; \
mysql -e CREATE DATABASE mydb DEFAULT COLLATE utf8_general_ci; &amp;&amp; \
/root/bin/goose -env=production up &amp;&amp; \
service mysql stop

EXPOSE 3306
CMD [mysqld_safe]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we build our image with &lt;code&gt;docker build -t mydb_test .&lt;/code&gt; command and run it with &lt;code&gt;docker run -p 3306:3306 mydb_test&lt;/code&gt;. The resulting container will have a fresh actual database instance with the latest migrations applied. Once the image is built it takes less than a second to start this container.&lt;/p&gt;

&lt;p&gt;The actual name of container and database is not important here, so we use &lt;code&gt;mydb&lt;/code&gt; and &lt;code&gt;mydb_test&lt;/code&gt; - simply a convention.&lt;/p&gt;

&lt;h2 id=&#34;go-tests&#34;&gt;Go tests&lt;/h2&gt;

&lt;p&gt;Now, it&amp;rsquo;s time to write some Go code. Remember, we want our test to be portable and issued with &lt;code&gt;go test&lt;/code&gt; command only. Let&amp;rsquo;s start our service_test.go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// +build integration

package main

import (
    &#34;testing&#34;
)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We place build tag &lt;code&gt;integration&lt;/code&gt; here to make sure this test will run only when explicitly asked with &lt;code&gt;--tags=integration&lt;/code&gt; flag. Yes, the test itself is fast, but still requires an external tool (Docker), so we&amp;rsquo;d better separate integration tests and unit tests.&lt;/p&gt;

&lt;p&gt;By the way, we could protect in with &lt;a href=&#34;https://golang.org/pkg/testing/#Short&#34;&gt;testing.Short&lt;/a&gt; flag, but the behavior is opposite in this case - long tests run by default.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
if testing.Short() {
        t.Skip(&#34;skipping test in short mode.&#34;)
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;running-docker-container&#34;&gt;Running Docker container&lt;/h3&gt;

&lt;p&gt;Before running our tests, we need to start our dependencies. There are a few packages to work with &lt;a href=&#34;https://docs.docker.com/engine/reference/api/docker_remote_api/&#34;&gt;Docker Remote API&lt;/a&gt; for Go, I will use the &lt;a href=&#34;http://github.com/fsouza/go-dockerclient&#34;&gt;one from fsouza&lt;/a&gt;, which I successfully using for quite a long time. Install it with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;go get -u github.com/fsouza/go-dockerclient&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To start the container, we have to write following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;client, err := docker.NewClientFromEnv()
if err != nil {
    t.Fatalf(&#34;Cannot connect to Docker daemon: %s&#34;, err)
}
c, err := client.CreateContainer(createOptions(&#34;mydb_test&#34;))
if err != nil {
    t.Fatalf(&#34;Cannot create Docker container: %s&#34;, err)
}
defer func() {
    if err := client.RemoveContainer(docker.RemoveContainerOptions{
        ID:    c.ID,
        Force: true,
    }); err != nil {
        t.Fatalf(&#34;cannot remove container: %s&#34;, err)
    }
}()

err = client.StartContainer(c.ID, &amp;docker.HostConfig{})
if err != nil {
    t.Fatalf(&#34;Cannot start Docker container: %s&#34;, err)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;createOptions() is a helper function returning struct with container creating options. We pass our docker container name to that function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func reateOptions(dbname string) docker.CreateContainerOptions {
    ports := make(map[docker.Port]struct{})
    ports[&#34;3306&#34;] = struct{}{}
    opts := docker.CreateContainerOptions{
        Config: &amp;docker.Config{
            Image:        dbname,
            ExposedPorts: ports,
        },
    }

    return opts
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that we need to write code which will wait for DB to start, extract IP address for connection, form DSN for database/sql driver and open the actual connection:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// wait for container to wake up
if err := waitStarted(client, c.ID, 5*time.Second); err != nil {
    t.Fatalf(&#34;Couldn&#39;t reach MySQL server for testing, aborting.&#34;)
}
c, err = client.InspectContainer(c.ID)
if err != nil {
    t.Fatalf(&#34;Couldn&#39;t inspect container: %s&#34;, err)
}

// determine IP address for MySQL
ip = strings.TrimSpace(c.NetworkSettings.IPAddress)

// wait MySQL to wake up
if err := waitReachable(ip+&#34;:3306&#34;, 5*time.Second); err != nil {
    t.Fatalf(&#34;Couldn&#39;t reach MySQL server for testing, aborting.&#34;)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we wait for two actions to happen: first is to get network inside container up, so we can obtain it&amp;rsquo;s IP address, and second, is MySQL service being actually started. Waiting functions are a bit tricky, so here they are:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// waitReachable waits for hostport to became reachable for the maxWait time.
func waitReachable(hostport string, maxWait time.Duration) error {
    done := time.Now().Add(maxWait)
    for time.Now().Before(done) {
        c, err := net.Dial(&#34;tcp&#34;, hostport)
        if err == nil {
            c.Close()
            return nil
        }
        time.Sleep(100 * time.Millisecond)
    }
    return fmt.Errorf(&#34;cannot connect %v for %v&#34;, hostport, maxWait)
}

// waitStarted waits for a container to start for the maxWait time.
func waitStarted(client *docker.Client, id string, maxWait time.Duration) error {
    done := time.Now().Add(maxWait)
    for time.Now().Before(done) {
        c, err := client.InspectContainer(id)
        if err != nil {
            break
        }
        if c.State.Running {
            return nil
        }
        time.Sleep(100 * time.Millisecond)
    }
    return fmt.Errorf(&#34;cannot start container %s for %v&#34;, id, maxWait)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, it&amp;rsquo;s enough to work with our container, but here is another issue comes in - if you run MacOS X or Windows, you use Docker via the proxy virtual machine with tiny linux, &lt;code&gt;docker-machine&lt;/code&gt; (or its predecessor, &lt;code&gt;boot2docker&lt;/code&gt;). It means you should use docker-machine&amp;rsquo;s IP address and not real container IP, which is not exposed outside of the docker-host linux VM.&lt;/p&gt;

&lt;h3 id=&#34;tuning-for-portability&#34;&gt;Tuning for portability&lt;/h3&gt;

&lt;p&gt;Again, let&amp;rsquo;s just write code to accomplish that, as it&amp;rsquo;s quite trivial:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// DockerMachineIP returns IP of docker-machine or boot2docker VM instance.
//
// If docker-machine or boot2docker is running and has IP, it will be used to
// connect to dockerized services (MySQL, etc).
//
// Basically, it adds support for MacOS X and Windows.
func DockerMachineIP() string {
    // Docker-machine is a modern solution for docker in MacOS X.
    // Try to detect it, with fallback to boot2docker
    var dockerMachine bool
    machine := os.Getenv(&#34;DOCKER_MACHINE_NAME&#34;)
    if machine != &#34;&#34; {
        dockerMachine = true
    }

    var buf bytes.Buffer

    var cmd *exec.Cmd
    if dockerMachine {
        cmd = exec.Command(&#34;docker-machine&#34;, &#34;ip&#34;, machine)
    } else {
        cmd = exec.Command(&#34;boot2docker&#34;, &#34;ip&#34;)
    }
    cmd.Stdout = &amp;buf

    if err := cmd.Run(); err != nil {
        // ignore error, as it&#39;s perfectly OK on Linux
        return &#34;&#34;
    }

    return buf.String()
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For working with docker-machine we will also need to pass port forwarding configuration in CreateContainerOptions.&lt;/p&gt;

&lt;p&gt;At this point, the amount of supporting code becomes quite notable, and it&amp;rsquo;s better to move all docker related code into separate a subpackage, perhaps in internal/ directory. Let&amp;rsquo;s name it &lt;code&gt;internal/dockertest&lt;/code&gt;. The source of this package can be &lt;a href=&#34;http://pastebin.com/faUUN0M1&#34;&gt;found here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;running-from-tests&#34;&gt;Running from tests&lt;/h3&gt;

&lt;p&gt;Now, all we need is to import our &lt;code&gt;internal/dockertest&lt;/code&gt; subpackage and start MySQL with a single line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// start db in docker container
dsn, deferFn, err := dockertest.StartMysql()
if err != nil {
    t.Fatalf(&#34;cannot start mysql in container for testing: %s&#34;, err)
}
defer deferFn()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pass &lt;code&gt;dsn&lt;/code&gt; to sql.Open() or your own service init function, and your code will connect to the database inside the container.
Note, that StartMysql() returns also a defer function, which will properly stop and remove container. Our test code knows nothing about underlying mechanisms. It just works as if it was a normal MySQL resource.&lt;/p&gt;

&lt;h3 id=&#34;testing-http-endpoints&#34;&gt;Testing http endpoints&lt;/h3&gt;

&lt;p&gt;Next step is to test http-endpoints. We may want to test response codes, proper error messages, expected headers or data format and so on. And, following our desire to not depend on any external testing scripts, we want to run all the tests within the Go code. And Go allows us to do so using net/http/httptest package.&lt;/p&gt;

&lt;p&gt;Honestly, &lt;code&gt;httptest&lt;/code&gt; was one of the most surprising things in Go, when I first saw it. net/http design was quite unusual and elegant for me, but httptest looked like a killer feature for testing http services. It leverages the power of interfaces in Go, and particularly, the http.ResponseWriter interface to achieve in-memory round-trip of http requests. We don&amp;rsquo;t need to ask OS to open ports, deal with permissions and busy ports - it&amp;rsquo;s all in memory.&lt;/p&gt;

&lt;p&gt;And as soon as gin framework implements http.Handler interface, which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can use it transparently with httptest. I will also use amazing GoConvey testing framework, which implements behaviour-driven testing for Go, and fully compatible with the default &lt;code&gt;go test&lt;/code&gt; workflow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func NewServer(db *sql.DB) *gin.Engine {
    r := gin.Default()
    r.Use(cors.Middleware(cors.Options{}))
    // more middlewares ...

    // Health check
    r.GET(&#34;/ping&#34;, ping)

    // CRUD resources
    usersRes := &amp;UsersResource{db: db}

    // Define routes
    api := r.Group(&#34;/api&#34;)
    {
        v1 := api.Group(&#34;/v1&#34;)
        {
            rest.CRUD(v1, &#34;/users&#34;, usersRes)
        }
    }

    return r
}
...
r := NewServer(db)
Convey(&#34;Users endpoints should respond correctly&#34;, t, func() {
    Convey(&#34;User should return empty list&#34;, func() {
        // it&#39;s safe to ignore error here, because we&#39;re manually entering URL
        req, _ := http.NewRequest(&#34;GET&#34;, &#34;http://localhost/api/v1/users&#34;, nil)
        w := httptest.NewRecorder()
        r.ServeHTTP(w, req)

        So(w.Code, ShouldEqual, http.StatusOK)
        body := strings.TrimSpace(w.Body.String())
        So(body, ShouldEqual, &#34;[]&#34;)
    })
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GoConvey has also an astonishing web UI, I guarantee you will start writing more tests just to see that nice blinking &amp;ldquo;PASS&amp;rdquo; message! :)&lt;/p&gt;

&lt;p&gt;And now, after you get the idea, we can add more tests for testing basic CRUD functionality for our simple service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;Convey(&#34;Create should return ID of a newly created user&#34;, func() {
    user := &amp;User{Name: &#34;Test user&#34;}
    data, err := json.Marshal(user)
    So(err, ShouldBeNil)
    buf := bytes.NewBuffer(data)
    req, err := http.NewRequest(&#34;POST&#34;, &#34;http://localhost/api/v1/users&#34;, buf)
    So(err, ShouldBeNil)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, req)

    So(w.Code, ShouldEqual, http.StatusOK)
    body := strings.TrimSpace(w.Body.String())
    So(body, ShouldEqual, &#34;1&#34;)
})
Convey(&#34;List should return one user with name &#39;Test user&#39;&#34;, func() {
    req, _ := http.NewRequest(&#34;GET&#34;, &#34;http://localhost/api/v1/users&#34;, nil)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, req)

    So(w.Code, ShouldEqual, http.StatusOK)
    body := w.Body.Bytes()
    var users []*User
    err := json.Unmarshal(body, &amp;users)
    So(err, ShouldBeNil)
    user := &amp;User{
        ID: 1,
        Name: &#34;Test user&#34;,
    }
    So(len(users), ShouldEqual, 1)
    So(users[0], ShouldResemble, user)
})&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;As you may see, Go not only make testing a lot easiers but also make use of BDD and TDD methodologies very easy to follow and opens new possibilities for cross-platform integration- and acceptance- testing.&lt;/p&gt;

&lt;p&gt;This example provided here is simplified on purpose, but it&amp;rsquo;s based on the real production code which is being tested in this way for more than 1.5 years and survived a number of refactorings and migrations&amp;rsquo; updates. On my Macbook Air, the whole test, from start to end (compile code, run docker container in docker-machine and test ~35 http requests, shut down the container) it takes about 3 seconds. On native Linux system it&amp;rsquo;s obviously a lot faster.&lt;/p&gt;

&lt;p&gt;One may ask why not publish this code as a separate library, and make the whole task (and article) even shorter. But the point here is that for every different service there may be a different set of service connections, different usage patterns and so on. And what is really important is that with Go it&amp;rsquo;s so easy to write this harness code for your needs, that you don&amp;rsquo;t have an excuse not to do this. Whether you need many similar containers in parallel (probably, you&amp;rsquo;ll need to randomize exposed ports), or you have to interconnect some services before starting them - you just write in Go, hiding all the complexity from the actual testing code.&lt;/p&gt;

&lt;p&gt;And always write tests! There is not excuse not to write them anymore.&lt;/p&gt;

&lt;p&gt;UPD: After writing the article, discovered the package &lt;a href=&#34;https://github.com/ory-am/dockertest&#34;&gt;dockertest&lt;/a&gt; by Aeneas Rekkas (&lt;a href=&#34;https://twitter.com/_aeneasr&#34;&gt;@_aeneasr&lt;/a&gt;), which does almost exactly the same as a code in this article, and looks pretty solid. Don&amp;rsquo;t miss it out!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Explaining Go error handling</title>
      <link>https://divan.github.io/posts/go_errors/</link>
      <pubDate>Mon, 02 Nov 2015 08:36:54 -0700</pubDate>
      
      <guid>https://divan.github.io/posts/go_errors/</guid>
      <description>&lt;p&gt;I recently translated great article&lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Errors are values&lt;/a&gt; by Rob Pikeand we discussed it in our &lt;a href=&#34;https://golangshow.com/&#34;&gt;podcast Golangshow&lt;/a&gt; (in russian). One thing I was surprised about is that even experienced Go developers sometimes do not understand the core idea of that article.&lt;/p&gt;

&lt;p&gt;Looking back, I remember my first impressions when I read it for the first time. It was similar to &lt;em&gt;It looks like Pike just adds some complexity to what couldve been solved gracefully with exceptions&lt;/em&gt;. I have never been fond of exceptions, but thats the first thought I remember. The example in the article was clearly asking for comparison with exceptions way to deal with errors and it didnt look like a winner here.&lt;/p&gt;

&lt;p&gt;Still I knew, there must be something more profound in these words&lt;em&gt;errors are values&lt;/em&gt;. After all, I was always comfortable with Go errors handling, so I gave some time to myself to absorb the article.&lt;/p&gt;

&lt;p&gt;And then I got it.&lt;/p&gt;

&lt;p&gt;Go doesnt want us to treat errors as something different from our main code. Erroneous situation is a first-class citizen in program flow design.&lt;/p&gt;

&lt;blockquote&gt;Errors shouldnt be hidden or ignored in the same way as you dont hide or ignore any other code. They are part of your logic and code.&lt;/blockquote&gt;

&lt;p&gt;Just try to imagine your way of thinking when you deal with usual conceptsvalues, conditions, loops etc., and apply it to the errors. Errors are the same level entities as the rest of your code. You dont ignore return values of other types for no reason, right? You dont ask language to bring special way to handle boolean variables, because if is boring. You dont ask yourself What should I do, if I dont know what to do with this slice on this abstraction level?. You just program the logic you need.&lt;/p&gt;

&lt;p&gt;Again, errors are values, and errors handling is a normal programming.&lt;/p&gt;

&lt;p&gt;Of course, there are always some patterns to deal with errors (like with any other programming conception), but they emerge naturally and fit perfectly in the existing language capabilities.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Lets try to illustrate it with an example, close enough to that one in the original article. Say, you have a taskmake repetitive writes with io.Writer and calculate number of bytes written, and stop after 1024-th byte. You start with straightforward approach:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var count, n int
n = write(one)
count += n
if count &gt;= 1024 {
    return
}

n = write(two)
count += n
if count &gt;= 1024 {
    return
}
// etc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/8033Wp9xly&#34;&gt;http://play.golang.org/p/8033Wp9xly&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Of course, you instantly see whats wrong with this code and, following DRY principle, you decide to deduplicate code, moving repeating parts to separate function or closure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var count int
cntWrite := func(s string) {
  n := write(s)
  count += n
  if count &gt;= 1024 {
    os.Exit(0)
  }
}

cntWrite(one)
cntWrite(two)
cntWrite(three)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/Hd12rk6wNk&#34;&gt;http://play.golang.org/p/Hd12rk6wNk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now its better, but still not perfect. You still need a closure, which depends on external variable. It also uses os.Exit(), which makes it hardly reusable after first refactoring. We can do better. Lets see how our thoughts flowwe have a write function, which does something else, except just writing bytes and we need it to be reusable and isolated entity. Lets refactor our code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type cntWriter struct {
    count int
    w io.Writer
}

func (cw *cntWriter) write(s string) {
    if cw.count &gt;= 1024 {
        return 
    }
    n := write(s)
    cw.count += n
}

func (cw *cntWriter) written() int { return cw.count }

func main() {
    cw := &amp;cntWriter{}
    cw.write(one)
    cw.write(two)
    cw.write(three)
    fmt.Printf(Written %d bytes\n, cw.written())
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/66Xd1fD8II&#34;&gt;http://play.golang.org/p/66Xd1fD8II&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now it looks much better, we can reuse this custom writer in other functions, its isolated and easy to test.&lt;/p&gt;

&lt;p&gt;Now, just replace counter with error value and youll get almost the same example as in original article about error handling. But take a note how easy and logical was your flow of thoughts towards this code. You wasnt distracted by looking for the special counting/passing features of the language. You simply was implementing the logic you need in the best possible way.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;This idea is profound enough and could be hard to grasp, especially with the mindset focused on The Only Right Way To Handle Errors. It definitely takes some time to absorb.&lt;/p&gt;

&lt;p&gt;Of course, its debatable, and I can find both a lot of pros and cons for this approach, as well as for others. Were not in the black&amp;amp;white world, but Go approach to errors is kind of mature and fresh at the same time, it extremely simple and hard to understand at the same time, it requires some rethinking and effort to get the idea. But, what is more important, it works great in practice.&lt;/p&gt;

&lt;p&gt;And once you get it, you stop fight the language. You stop looking for special ways to handle or hide errors. Go makes you respect errors as any other part of your program. You just handle them, without expecting language do the magic for you. In the long run, your code becomes better, even if do not realize it yet.&lt;/p&gt;

&lt;p&gt;Now, come and read this article again&lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Errors are values&lt;/a&gt;and try to get the gist of it with this perspective.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>