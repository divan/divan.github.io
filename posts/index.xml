<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on divan&#39;s blog</title>
    <link>https://divan.github.io/posts/</link>
    <description>Recent content in Posts on divan&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 31 Mar 2016 04:30:29 +0300</lastBuildDate>
    <atom:link href="https://divan.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LeftPad and Go: can tooling help?</title>
      <link>https://divan.github.io/posts/160331_depscheck/</link>
      <pubDate>Thu, 31 Mar 2016 04:30:29 +0300</pubDate>
      
      <guid>https://divan.github.io/posts/160331_depscheck/</guid>
      <description>

&lt;p&gt;You&amp;rsquo;ve probably heard that story about NPM community and &lt;a href=&#34;https://www.npmjs.com/package/left-pad&#34;&gt;LeftPad&lt;/a&gt; package, that broke thousands JavaScript projects worldwide. There was a nice follow-up article titled &lt;a href=&#34;http://www.haneycodes.net/npm-left-pad-have-we-forgotten-how-to-program/&#34;&gt;&amp;ldquo;Have We Forget How To Program&amp;rdquo;&lt;/a&gt; and one guy even created &lt;a href=&#34;http://left-pad.io&#34;&gt;left-pad.io&lt;/a&gt; - Left-Pad As A Service web service. People got a lot of fun discussing this story.&lt;/p&gt;

&lt;p&gt;I personally find this story amazing, because there is no single point of failure, but rather a set of thing and coincidences resulted in a disaster. Every person I spoke about left-pad story sees it through it&amp;rsquo;s own lens of concern. Some blame JS-community, some talks about how important vendoring is nowadays and others stands for absolutist views of the DRY principle.&lt;/p&gt;

&lt;p&gt;For me my lens were the chances of getting into something similar in Go ecosystem. Of course, after initial thinking, I came to resolution that there is nothing to worry about - Go community doesn&amp;rsquo;t tend to create packages for every single simple function over there. Yes, someone inspired by NPM LeftPad story created &lt;a href=&#34;https://github.com/keltia/leftpad&#34;&gt;similar package for Go&lt;/a&gt; - but the fact it was created after that fiasco story only confirms my  thoughts.&lt;/p&gt;

&lt;p&gt;Moreover, there is even a &lt;a href=&#34;http://go-proverbs.github.io/&#34;&gt;Go proverb&lt;/a&gt; dedicated to this specific thing:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A little copying is better than a little dependency.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you struggle to understand how it applies with DRY and why it&amp;rsquo;s a wise point, I suggest you check out &lt;a href=&#34;https://www.youtube.com/watch?v=PAAkCSZUG1c&#34;&gt;this video&lt;/a&gt; on a subject.&lt;/p&gt;

&lt;p&gt;But one thought was spinning in my head - can we do better and use tooling to check for the &amp;lsquo;little dependency&amp;rsquo;? I believe that tooling is a great way to enforce some good practices and views, and &lt;code&gt;go fmt&lt;/code&gt; is a greates evidence of it. Why can&amp;rsquo;t we make a tool that would check package imports and suggest to &lt;em&gt;&amp;ldquo;take a look at this small LeftPad dependency of only one small function&amp;rdquo;&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Meet &lt;a href=&#34;https://github.com/divan/depscheck&#34;&gt;depscheck&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;depscheck:ccd3f74ebf4261596c9359f9d8d5dd41&#34;&gt;DepsCheck&lt;/h1&gt;

&lt;p&gt;So, that&amp;rsquo;s how &lt;strong&gt;depscheck&lt;/strong&gt; was born. I spent a weekend, learning how to work with go/{ast,parser,types,loader} packages and after 10-th refactoring finally came up with a tool that was doing exactly I wanted to.&lt;/p&gt;

&lt;p&gt;Here is a description for GitHub:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DepsCheck - Dependency checker for Golang (Go) packages. Prints stats and suggests to remove small LeftPad-like imports if any&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It analyzes package or arbitrary *.go files using AST-parser and calculates some stats about dependencies. Namely, number of calls/selectors of dependency, funcs/methods&amp;rsquo; LOC (Lines Of Code), Cumulative LOCs (whenever possible, dropping it for recursion), Depth (number of nested calls to more external dependencies) and DepthInternal(the same, but for internal function calls). In most cases it&amp;rsquo;s enough to make some calculations and analysis to find &lt;em&gt;&amp;lsquo;small dependencies&amp;rsquo;&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;quick-intro:ccd3f74ebf4261596c9359f9d8d5dd41&#34;&gt;Quick Intro&lt;/h3&gt;

&lt;p&gt;Here is quick intro and dogfooding demo of the tool.&lt;/p&gt;

&lt;p&gt;First, install the tool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/divan/depscheck
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then invoke as simple as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;depscheck -v github.com/divan/depscheck
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/divan/depscheck/raw/master/demo/depscheck.png&#34; alt=&#34;Demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There is a detailed table view of dependencies usage, totals and breakdown by packages, and in the end, the tool says - hey, your dependencies are sane. It means, no dependencies of suspiciously small usage size.&lt;/p&gt;

&lt;p&gt;In case it finds potential candidate for copying into your codebase and removing from the dependency list, it outputs something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ depscheck github.com/divan/expvarmon
github.com/divan/expvarmon: 4 packages, 1022 LOC, 93 calls, 11 depth, 23 depth int.
 - Package byten (github.com/pyk/byten) is a good candidate for removing from dependencies.
   Only 19 LOC used, in 1 calls, with 2 level of nesting
 - Package ranges (github.com/bsiegert/ranges) is a good candidate for removing from dependencies.
   Only 29 LOC used, in 1 calls, with 0 level of nesting
Run with -v option to see detailed stats for dependencies.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And by the way, in an example above it totally make sense. Rerunning with &lt;code&gt;-v&lt;/code&gt; options to see the detials, it&amp;rsquo;s easy to see that package only uses single flat function from &lt;code&gt;ranges&lt;/code&gt; of 29 lines of code - ranges.Parse, and it can be easily copied to my codebase, if license permits, of course. It removes the whole bunch of burden in case I&amp;rsquo;ll need to vendor dependencies or use some vendoring tools.&lt;/p&gt;

&lt;p&gt;Of course, this suggestion doesn&amp;rsquo;t mean you have to do it. It just asks you to pay attention to these particular imports if you want to make your codebase a little bit better. It&amp;rsquo;s up to me to decide what to do with this import. The tools suggestions are recommendation only.&lt;/p&gt;

&lt;h3 id=&#34;how-small-is-small-dependency:ccd3f74ebf4261596c9359f9d8d5dd41&#34;&gt;How small is small dependency&lt;/h3&gt;

&lt;p&gt;You may ask now - how do you determine if the dependency is small enough to be a candidate for elimination? Good question, and I don&amp;rsquo;t have one single source of truth here, so I&amp;rsquo;ve implemented it based on my view of common sense here. To be short, here is the responsible method at the moment of writing this article:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CanBeAvoided attempts to classify if package usage is small enough
// to suggest user avoid this package as a dependency and
// instead copy/embed it&#39;s code into own project (if license permits).
func (p *PackageStat) CanBeAvoided() bool {
	// If this dependency is using another dependencies,
	// it&#39;s almost for sure - no. For internal dependency, let&#39;s
	// allow just two level of nesting.
	if p.Depth &amp;gt; 0 {
		return false
	}
	if p.DepthInternal &amp;gt; 2 {
		return false
	}

	if p.DepsCount &amp;gt; 3 {
		return false
	}

	// Because 42
	if p.LOCCum &amp;gt; 42 {
		return false
	}

	return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, it&amp;rsquo;s pretty straightforward, no machine learning here. Just hardcore universal constants :) It&amp;rsquo;s not perfect, but hey, at least, it can detect LeftPad package, mentioned above!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ depscheck leftpad.go
main: 1 packages, 17 LOC, 1 calls, 0 depth, 1 depth int.
 - Package leftpad (github.com/keltia/leftpad) is a good candidate for removing from dependencies.
   Only 17 LOC used, in 1 calls, with 1 level of nesting
Run with -v option to see detailed stats for dependencies.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m looking forward to hear suggestions on how to do it better. Maybe it&amp;rsquo;s worth to calculate total LOC of the package and look at the percentage of LOC involved? Feel free to tell your view on how small is &amp;ldquo;small dependency&amp;rdquo; could be from the perspective of the machine.&lt;/p&gt;

&lt;p&gt;Anyway, it&amp;rsquo;s always possible to manually inspect detailed output and filter small enough dependencies by yourself.&lt;/p&gt;

&lt;p&gt;Also, please, don&amp;rsquo;t rely on these numbers heavily. It&amp;rsquo;s likely to be somehow incorrect in some cases. Yes, it&amp;rsquo;s tested with simple cases, but there are lot of cases, where it&amp;rsquo;s even impossible to tell what is a &amp;ldquo;correct&amp;rdquo; value. For example, how do you calculate Cumulative number of lines for two functions with circular depency? There are also probably some bugs I didn&amp;rsquo;t catch (hey, it survived 10 refactorings in 3 days!), so feel free to open an issue or send a PR.&lt;/p&gt;

&lt;h1 id=&#34;stdlib:ccd3f74ebf4261596c9359f9d8d5dd41&#34;&gt;Stdlib&lt;/h1&gt;

&lt;p&gt;Depscheck also can work with stdlib packages. Normally it threats stdlib imports as &amp;lsquo;internal&amp;rsquo; and doesn&amp;rsquo;t analyze/report them. But you can explicitly ask for that using &lt;code&gt;-stdlib&lt;/code&gt; command line flag. Suggestions are silenced in this mode because stdlib is smarter than this tool. Anyway, it can give interesting insights into your package or application.&lt;/p&gt;

&lt;p&gt;For example, here is the sample output for checking against stdlib &lt;code&gt;time&lt;/code&gt; package (though, you can use -stdlib flag for any package, not only stdlib):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ depscheck -stdlib -v time
time: 4 packages, 294 LOC, 50 calls, 17 depth, 3 depth int.
+---------+-------+----------+--------+-------+-----+--------+-------+----------+
|   PKG   | RECV  |   NAME   |  TYPE  | COUNT | LOC | LOCCUM | DEPTH | DEPTHINT |
+---------+-------+----------+--------+-------+-----+--------+-------+----------+
| errors  |       | New      | func   |    31 |   2 |      2 |     0 |        0 |
| runtime |       | GOROOT   | func   |     2 |   6 |      6 |     0 |        0 |
| sync    | *Once | Do       | method |     1 |  11 |     90 |     2 |        3 |
|         |       | Once     | type   |     1 |     |        |       |          |
| syscall |       | ENOENT   | const  |     1 |     |        |       |          |
|         |       | O_RDONLY | const  |     2 |     |        |       |          |
|         |       | SIGCHLD  | const  |     1 |     |        |       |          |
|         |       | Close    | func   |     2 |   6 |      6 |     0 |        0 |
|         |       | Getenv   | func   |     2 |  20 |    149 |    13 |        0 |
|         |       | Getpid   | func   |     1 |   4 |      4 |     0 |        0 |
|         |       | Kill     | func   |     1 |   1 |      1 |     0 |        0 |
|         |       | Open     | func   |     2 |  13 |     13 |     0 |        0 |
|         |       | Read     | func   |     2 |  14 |     16 |     2 |        0 |
|         |       | Seek     | func   |     1 |   7 |      7 |     0 |        0 |
+---------+-------+----------+--------+-------+-----+--------+-------+----------+
+---------+---------+-------+-------+--------+-------+----------+
|   PKG   |  PATH   | COUNT | CALLS | LOCCUM | DEPTH | DEPTHINT |
+---------+---------+-------+-------+--------+-------+----------+
| errors  | errors  |     1 |    31 |      2 |     0 |        0 |
| runtime | runtime |     1 |     2 |      6 |     0 |        0 |
| sync    | sync    |     2 |     2 |     90 |     2 |        3 |
| syscall | syscall |    10 |    15 |    196 |    15 |        0 |
+---------+---------+-------+-------+--------+-------+----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may even run it against the whole stdlib and build some statistics in R Studio or your favorite statistics tool. Let&amp;rsquo;s use &lt;code&gt;go list std&lt;/code&gt; command to get all stdlib packages names and feed them to &lt;em&gt;depcheck&lt;/em&gt;: There is a special &lt;code&gt;-totalonly&lt;/code&gt; flag, which tells depscheck to output only totals oneliner, which is easily parseable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for i in $(go list std); do depscheck -stdlib -totalonly $i; done
archive/tar: 13 packages, 3328 LOC, 174 calls, 5 depth, 78 depth int.
archive/zip: 13 packages, 2284 LOC, 184 calls, 24 depth, 84 depth int.
bufio: 4 packages, 84 LOC, 60 calls, 0 depth, 0 depth int.
bytes: 4 packages, 699 LOC, 79 calls, 0 depth, 26 depth int.
compress/bzip2: 3 packages, 58 LOC, 19 calls, 0 depth, 4 depth int.
compress/flate: 7 packages, 255 LOC, 52 calls, 3 depth, 10 depth int.
compress/gzip: 8 packages, 622 LOC, 72 calls, 1 depth, 36 depth int.
compress/lzw: 4 packages, 42 LOC, 25 calls, 1 depth, 3 depth int.
compress/zlib: 7 packages, 877 LOC, 59 calls, 1 depth, 47 depth int.
container/heap: 1 packages, 0 LOC, 13 calls, 0 depth, 0 depth int.
container/list: 0 packages, 0 LOC, 0 calls, 0 depth, 0 depth int.
container/ring: 0 packages, 0 LOC, 0 calls, 0 depth, 0 depth int.
crypto: 3 packages, 88 LOC, 6 calls, 0 depth, 2 depth int.
crypto/aes: 4 packages, 109 LOC, 5 calls, 0 depth, 3 depth int.
crypto/cipher: 4 packages, 21 LOC, 12 calls, 0 depth, 1 depth int.
crypto/des: 3 packages, 100 LOC, 9 calls, 0 depth, 2 depth int.
crypto/dsa: 3 packages, 6021 LOC, 89 calls, 0 depth, 409 depth int.
crypto/ecdsa: 9 packages, 4059 LOC, 94 calls, 2 depth, 269 depth int.
crypto/elliptic: 3 packages, 2677 LOC, 298 calls, 4 depth, 180 depth int.
crypto/hmac: 3 packages, 19 LOC, 15 calls, 0 depth, 1 depth int.
crypto/md5: 3 packages, 5 LOC, 5 calls, 0 depth, 0 depth int.
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A couple of manipulations to convert it to CSV and here is the histogram of number of imported packages in stdlib:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/stdlib_deps.png&#34; alt=&#34;Histogram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, feel free to play with this statistics. Maybe you&amp;rsquo;ll find it useful.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:ccd3f74ebf4261596c9359f9d8d5dd41&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I constantly admire the long-striking power of the core ideas around Go design. Simple grammar and spec allowed me to build this tool in a weekend, without any prior experience of working with AST representation of source code. It&amp;rsquo;s inherently hard, but the guys behind Go&amp;rsquo;s source code parsing packages are doing amazing job. I benefit every single day by different linters, bundled together in &lt;a href=&#34;https://github.com/alecthomas/gometalinter&#34;&gt;GoMetaLinter&lt;/a&gt; package (a must have thing!), and these static code analysis tools are making our code better.&lt;/p&gt;

&lt;p&gt;Now I also feel a little bit safer because that Go proverb mentioned in the beginning is now materialized in a depscheck tool. And hopefully, it will make us, as a community, one more step further from the slightest possibility to fall into the trend that resulted in that LeftPad fiasco.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Visualizing Concurrency in Go</title>
      <link>https://divan.github.io/posts/go_concurrency_visualize/</link>
      <pubDate>Sun, 24 Jan 2016 18:31:12 -0300</pubDate>
      
      <guid>https://divan.github.io/posts/go_concurrency_visualize/</guid>
      <description>

&lt;p&gt;One of the strongest sides of Go programming language is a built-in concurrency based on &lt;a href=&#34;https://en.wikipedia.org/wiki/Communicating_sequential_processes&#34;&gt;Tony Hoare&amp;rsquo;s CSP&lt;/a&gt; paper. Go is designed with concurrency in mind and allows us to build complex concurrent pipelines. But have you ever wondered - how various concurrency patterns look like?&lt;/p&gt;

&lt;p&gt;Of course, you have. We&amp;rsquo;re all thinking mostly by visualization in one form or another. If I ask you something involving &amp;ldquo;numbers from 1 to 100&amp;rdquo; you will have your own image of the series in your head, even without realizing it. For example, I imagine it as a line going from me with numbers from 1 to 20, then it turns 90 degrees to the right and continues to the 1000+. I recall from very young period of my life that in our kindergarten there were numbers in a cloakroom, written along the wall, and number 20 was exactly at the corner. You probably have your own image of numbers. Another common example is the visual representation of the full year with four seasons - some people see it as a box, other - as a circle.&lt;/p&gt;

&lt;p&gt;Anyway, I want to show you my attempt to visualize common concurrency patterns using Go and WebGL. It more or less represents the way I see  concurrent programs in my head. Would be pretty interesting to hear how much it differs from images in your head. I especially would love to see how Rob Pike or Sameer Ajmani imagine concurrency. I bet I&amp;rsquo;d be quite interesting.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s start with the very basic &amp;ldquo;Hello, Concurrent World&amp;rdquo; example, to get ourselves familiar with the concept of my attempt.&lt;/p&gt;

&lt;h3 id=&#34;hello-concurrent-world:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Hello, Concurrent world&lt;/h3&gt;

&lt;p&gt;The code is quite simple - single channel, single goroutine, one write, one read.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

func main() {
    // create new channel of type int
    ch := make(chan int)

    // start new anonymous goroutine
    go func() {
        // send 42 to channel
        ch &lt;- 42
    }()
    // read from channel
    &lt;-ch
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/hello/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/hello.gif&#34; alt=&#34;Hello, World&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here the blue lines represent goroutines running down through time. Thin blue lines connecting &amp;lsquo;main&amp;rsquo; and &amp;lsquo;go #19&amp;rsquo; are marks for start and stop goroutine, revealing parent-children relation and, finally, red arrow shows us the send/recv action. While it&amp;rsquo;s actually two separate actions, I try to animate as a single event &amp;ldquo;send from A to B&amp;rdquo;. The &amp;ldquo;#19&amp;rdquo; in the goroutine name is the actual goroutine internal ID, obtained from runtime with a trick suggested by Scott Mansfield in &lt;a href=&#34;http://blog.sgmansfield.com/2015/12/goroutine-ids/&#34;&gt;&amp;ldquo;Goroutine IDs&amp;rdquo;&lt;/a&gt; article.&lt;/p&gt;

&lt;h3 id=&#34;timers:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Timers&lt;/h3&gt;

&lt;p&gt;In fact, you can build a simple timer with this approach - create a channel, start goroutine which writes to this channel after given duration and returns this channel to the caller of your func. The caller then blocks on reading from the channel for the exact amount of time. Let&amp;rsquo;s run such timer 24 times and try to visualize it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import &#34;time&#34;

func timer(d time.Duration) &lt;-chan int {
    c := make(chan int)
    go func() {
        time.Sleep(d)
        c &lt;- 1
    }()
    return c
}

func main() {
    for i := 0; i &lt; 24; i++ {
        c := timer(1 * time.Second)
        &lt;-c
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/timers/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/timers.gif&#34; alt=&#34;Recurrent Timers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pretty neat, right? Let&amp;rsquo;s move on.&lt;/p&gt;

&lt;h3 id=&#34;ping-pong:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Ping-pong&lt;/h3&gt;

&lt;p&gt;This nice concurrency example was found in a great talk by googler Sameer Ajmani &lt;a href=&#34;https://talks.golang.org/2013/advconc.slide#1&#34;&gt;&amp;ldquo;Advanced Go Concurrency Patterns&amp;rdquo;&lt;/a&gt;. Of course, this pattern isn&amp;rsquo;t very advanced, but for those who only get themselves familiar with Go concurrency it may look quite fresh and interesting.&lt;/p&gt;

&lt;p&gt;Here we have a channel as a table of the ping-pong game. The ball is an integer variable, and two goroutines-players that &amp;lsquo;hit&amp;rsquo; the ball, increasing its value (hits counter).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import &#34;time&#34;

func main() {
    var Ball int
    table := make(chan int)
    go player(table)
    go player(table)

    table &lt;- Ball
    time.Sleep(1 * time.Second)
    &lt;-table
}

func player(table chan int) {
    for {
        ball := &lt;-table
        ball++
        time.Sleep(100 * time.Millisecond)
        table &lt;- ball
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/pingpong/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/pingpong.gif&#34; alt=&#34;Ping-Pong&#34; /&gt;
At this point I&amp;rsquo;d suggest you to click that &lt;a href=&#34;https://divan.github.io/demos/pingpong/&#34;&gt;link above&lt;/a&gt; to the interactive WebGL animation (Ctrl/Cmd-Click to open it in a new tab) and play around with interactively. You can slowdown animation, speedup and see it in different angles.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s run three players instead of two.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;    go player(table)
    go player(table)
    go player(table)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/pingpong3/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/pingpong3.gif&#34; alt=&#34;Ping-Pong 3&#34; /&gt;
We can see here that each player takes its turn sequentially and you may wonder why is it so. Why we see this strict order in goroutines receiving the ball?&lt;/p&gt;

&lt;p&gt;The answer is because Go runtime holds waiting &lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/chan.go#L34&#34;&gt;FIFO queue for receivers&lt;/a&gt; (goroutines ready to receive on the particular channel), and in our case every player gets ready just after he passed the ball on the table. Let&amp;rsquo;s check it with more complex example and run 100 table tennis players.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;for i := 0; i &lt; 100; i++ {
    go player(table)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/pingpong100/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/pingpong100.gif&#34; alt=&#34;Ping-Pong 100&#34; /&gt;
The FIFO order is now obvious, isn&amp;rsquo;t it? We can spawn a million goroutines (they&amp;rsquo;re cheap), but for our goal that would be overkill.
Let&amp;rsquo;s see something different to play with. For example, common messaging patterns.&lt;/p&gt;

&lt;h3 id=&#34;fan-in:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Fan-In&lt;/h3&gt;

&lt;p&gt;One of the popular patterns in the concurrent world is a so called &lt;em&gt;fan-in&lt;/em&gt; pattern. It&amp;rsquo;s the opposite of the &lt;em&gt;fan-out&lt;/em&gt; pattern, which we will cover later. To be short, fan-in is a function reading from the multiple inputs and multiplexing all into the single channel.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

func producer(ch chan int, d time.Duration) {
    var i int
    for {
        ch &lt;- i
        i++
        time.Sleep(d)
    }
}

func reader(out chan int) {
    for x := range out {
        fmt.Println(x)
    }
}

func main() {
    ch := make(chan int)
    out := make(chan int)
    go producer(ch, 100*time.Millisecond)
    go producer(ch, 250*time.Millisecond)
    go reader(out)
    for i := range ch {
        out &lt;- i
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/fanin/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/fanin.gif&#34; alt=&#34;Fan-In Pattern&#34; /&gt;
As we can see, first &lt;em&gt;producer&lt;/em&gt; generates values each 100 milliseconds, and second one - each 250 milliseconds, but &lt;em&gt;reader&lt;/em&gt; receives values from both producers immediately. Effectively, multiplexing happens in a range loop in &lt;em&gt;main&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;workers:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Workers&lt;/h3&gt;

&lt;p&gt;The opposite pattern to &lt;em&gt;fan-in&lt;/em&gt; is a &lt;em&gt;fan-out&lt;/em&gt; or &lt;em&gt;workers&lt;/em&gt; pattern. Multiple goroutines can read from a single channel, distributing an amount of work between CPU cores, hence the &lt;em&gt;workers&lt;/em&gt; name. In Go, this pattern is easy to implement - just start a number of goroutines with channel as parameter, and just send values to that channel - distributing and multiplexing will be done by Go runtime, automagically :)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;fmt&#34;
    &#34;sync&#34;
    &#34;time&#34;
)

func worker(tasksCh &lt;-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        task, ok := &lt;-tasksCh
        if !ok {
            return
        }
        d := time.Duration(task) * time.Millisecond
        time.Sleep(d)
        fmt.Println(&#34;processing task&#34;, task)
    }
}

func pool(wg *sync.WaitGroup, workers, tasks int) {
    tasksCh := make(chan int)

    for i := 0; i &lt; workers; i++ {
        go worker(tasksCh, wg)
    }

    for i := 0; i &lt; tasks; i++ {
        tasksCh &lt;- i
    }

    close(tasksCh)
}

func main() {
    var wg sync.WaitGroup
    wg.Add(36)
    go pool(&amp;wg, 36, 50)
    wg.Wait()
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/workers/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/workers.gif&#34; alt=&#34;Workers&#34; /&gt;
One thing worth to note here: the parallelism. As you can see, all goroutines &amp;lsquo;run&amp;rsquo; in parallel, waiting for channel to give them &amp;lsquo;work&amp;rsquo; to do. Given the animation above, it&amp;rsquo;s easy to spot that goroutines receive their work almost immediately one after another. Unfortunately, this animation doesn&amp;rsquo;t show in color where goroutine really does work or just waits for input, but this exact animation was recorded with GOMAXPROCS=4, so only 4 goroutines effectively run in parallel. We will get to this subject shortly.&lt;/p&gt;

&lt;p&gt;For now, let&amp;rsquo;s do something more complex, and start workers that have their own workers (subworkers).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;fmt&#34;
    &#34;sync&#34;
    &#34;time&#34;
)

const (
    WORKERS    = 5
    SUBWORKERS = 3
    TASKS      = 20
    SUBTASKS   = 10
)

func subworker(subtasks chan int) {
    for {
        task, ok := &lt;-subtasks
        if !ok {
            return
        }
        time.Sleep(time.Duration(task) * time.Millisecond)
        fmt.Println(task)
    }
}

func worker(tasks &lt;-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        task, ok := &lt;-tasks
        if !ok {
            return
        }

        subtasks := make(chan int)
        for i := 0; i &lt; SUBWORKERS; i++ {
            go subworker(subtasks)
        }
        for i := 0; i &lt; SUBTASKS; i++ {
            task1 := task * i
            subtasks &lt;- task1
        }
        close(subtasks)
    }
}

func main() {
    var wg sync.WaitGroup
    wg.Add(WORKERS)
    tasks := make(chan int)

    for i := 0; i &lt; WORKERS; i++ {
        go worker(tasks, &amp;wg)
    }

    for i := 0; i &lt; TASKS; i++ {
        tasks &lt;- i
    }

    close(tasks)
    wg.Wait()
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/workers2/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/workers2.gif&#34; alt=&#34;Workers of workers&#34; /&gt;
Nice. Of course, we can set number of workers and subworkers to much higher values, but I tried to make animations clear and understandable.&lt;/p&gt;

&lt;p&gt;There are even cooler fan-out patterns do exist, like the dynamic amount of workers/subworkers, with sending channels over channels, but the idea of fan-out should be clear for now.&lt;/p&gt;

&lt;h3 id=&#34;servers:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Servers&lt;/h3&gt;

&lt;p&gt;Next common pattern is similar to fan-out, but with goroutines spawned for the short period of time, just to accomplish some task. It&amp;rsquo;s typically used for implementing servers - create a listener, run accept() in a loop and start goroutine for each accepted connection. It&amp;rsquo;s very expressive and allows to implement server handlers as simple as possible. Take a look at this simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import &#34;net&#34;

func handler(c net.Conn) {
    c.Write([]byte(&#34;ok&#34;))
    c.Close()
}

func main() {
    l, err := net.Listen(&#34;tcp&#34;, &#34;:5000&#34;)
    if err != nil {
        panic(err)
    }
    for {
        c, err := l.Accept()
        if err != nil {
            continue
        }
        go handler(c)
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/servers/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/servers.gif&#34; alt=&#34;Servers&#34; /&gt;
It&amp;rsquo;s not very interesting - it seems there is nothing happens in terms of concurrency. Of course, under the hood there is a ton of complexity, which is deliberately hidden from us. &lt;a href=&#34;https://www.youtube.com/watch?v=rFejpH_tAHM&#34;&gt;&amp;ldquo;Simplicity is complicated&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s go back to concurrency and add some interaction to our server. Let&amp;rsquo;s say, each handler wants to write asynchronously to the logger. Logger itself, in our example, is a separate goroutine which does the job.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;fmt&#34;
    &#34;net&#34;
    &#34;time&#34;
)

func handler(c net.Conn, ch chan string) {
    ch &lt;- c.RemoteAddr().String()
    c.Write([]byte(&#34;ok&#34;))
    c.Close()
}

func logger(ch chan string) {
    for {
        fmt.Println(&lt;-ch)
    }
}

func server(l net.Listener, ch chan string) {
    for {
        c, err := l.Accept()
        if err != nil {
            continue
        }
        go handler(c, ch)
    }
}

func main() {
    l, err := net.Listen(&#34;tcp&#34;, &#34;:5000&#34;)
    if err != nil {
        panic(err)
    }
    ch := make(chan string)
    go logger(ch)
    go server(l, ch)
    time.Sleep(10 * time.Second)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/servers2/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/servers2.gif&#34; alt=&#34;Servers 2&#34; /&gt;
Quite demonstrative, isn&amp;rsquo;t it? But it&amp;rsquo;s easy to see that our &lt;em&gt;logger&lt;/em&gt; goroutine can quickly become a bottleneck if the number of requests increase and logging action take some time (preparing and encoding data, for example). We can use an already known fan-out pattern. Let&amp;rsquo;s do it.&lt;/p&gt;

&lt;h3 id=&#34;server-worker:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Server + Worker&lt;/h3&gt;

&lt;p&gt;Server with worker example is a bit advanced version of the logger. It not only does some work but sends the result of its work back to the pool using &lt;em&gt;results&lt;/em&gt; channel. Not a big deal, but it extends our logger example to something more practical.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see the code and animation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &#34;net&#34;
    &#34;time&#34;
)

func handler(c net.Conn, ch chan string) {
    addr := c.RemoteAddr().String()
    ch &lt;- addr
    time.Sleep(100 * time.Millisecond)
    c.Write([]byte(&#34;ok&#34;))
    c.Close()
}

func logger(wch chan int, results chan int) {
    for {
        data := &lt;-wch
        data++
        results &lt;- data
    }
}

func parse(results chan int) {
    for {
        &lt;-results
    }
}

func pool(ch chan string, n int) {
    wch := make(chan int)
    results := make(chan int)
    for i := 0; i &lt; n; i++ {
        go logger(wch, results)
    }
    go parse(results)
    for {
        addr := &lt;-ch
        l := len(addr)
        wch &lt;- l
    }
}

func server(l net.Listener, ch chan string) {
    for {
        c, err := l.Accept()
        if err != nil {
            continue
        }
        go handler(c, ch)
    }
}

func main() {
    l, err := net.Listen(&#34;tcp&#34;, &#34;:5000&#34;)
    if err != nil {
        panic(err)
    }
    ch := make(chan string)
    go pool(ch, 4)
    go server(l, ch)
    time.Sleep(10 * time.Second)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/servers3/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/servers3.gif&#34; alt=&#34;Server + Worker&#34; /&gt;
We distributed work between 4 goroutines, effectively improving the throughput of the logger, but from this animation, we can see that logger still may be the source of problems. Thousands of connections converge in a single channel before being distributed and it may result in a logger being bottleneck again. But, of course, it will happen on much higher loads.&lt;/p&gt;

&lt;h3 id=&#34;concurrent-prime-sieve:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Concurrent Prime Sieve&lt;/h3&gt;

&lt;p&gt;Enough fan-in/fan-out fun. Let&amp;rsquo;s see more sophisticated concurrency algorithms. One of my favorite examples is a Concurrent Prime Sieve, found in &lt;a href=&#34;https://talks.golang.org/2012/concurrency.slide&#34;&gt;&amp;ldquo;Go Concurrency Patterns&amp;rdquo;&lt;/a&gt; talk. Prime Sieve, or &lt;a href=&#34;https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&#34;&gt;Sieve of Eratosthenes&lt;/a&gt; is an ancient algorithm for finding prime number up to the given limit. It works by eliminating multiples of all primes in a sequential manner. Naive algorithm is not really efficient, especially on multicore machines.&lt;/p&gt;

&lt;p&gt;The concurrent variant of this algorithm uses goroutines for filtering numbers - one goroutine per every prime discovered, and channels for sending numbers from the generator to filters. When prime is found, it&amp;rsquo;s being sent via the channel to the &lt;em&gt;main&lt;/em&gt; for output. Of course, this algorithm is also not very efficient, especially if you want to find large primes and look for the lowest Big O complexity, but I find it extremely elegant.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// A concurrent prime sieve
package main

import &#34;fmt&#34;

// Send the sequence 2, 3, 4, ... to channel &#39;ch&#39;.
func Generate(ch chan&lt;- int) {
    for i := 2; ; i++ {
        ch &lt;- i // Send &#39;i&#39; to channel &#39;ch&#39;.
    }
}

// Copy the values from channel &#39;in&#39; to channel &#39;out&#39;,
// removing those divisible by &#39;prime&#39;.
func Filter(in &lt;-chan int, out chan&lt;- int, prime int) {
    for {
        i := &lt;-in // Receive value from &#39;in&#39;.
        if i%prime != 0 {
            out &lt;- i // Send &#39;i&#39; to &#39;out&#39;.
        }
    }
}

// The prime sieve: Daisy-chain Filter processes.
func main() {
    ch := make(chan int) // Create a new channel.
    go Generate(ch)      // Launch Generate goroutine.
    for i := 0; i &lt; 10; i++ {
        prime := &lt;-ch
        fmt.Println(prime)
        ch1 := make(chan int)
        go Filter(ch, ch1, prime)
        ch = ch1
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/primesieve/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/primesieve.gif&#34; alt=&#34;PrimeSieve&#34; /&gt;
Feel free to play with this animation in interactive mode. I like how illustrative it is - it really can help understand this algorithm better. The &lt;em&gt;generate&lt;/em&gt; goroutine emits every integer number, starting from 2, and each new goroutine filters out only specific prime multiples - 2, 3, 5, 7&amp;hellip;, sending first found prime to &lt;em&gt;main&lt;/em&gt;. If you rotate it to see from the top, you&amp;rsquo;ll see all numbers being sent from goroutines to main are prime numbers. Beautiful algorithm, especially in 3D.&lt;/p&gt;

&lt;h3 id=&#34;gomaxprocs:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;GOMAXPROCS&lt;/h3&gt;

&lt;p&gt;Now, let&amp;rsquo;s go back to our workers example. Remember, I told that it was run with GOMAXPROCS=4? That&amp;rsquo;s because all these animations are not art work, they are real traces of real programs.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s refresh our memory on what &lt;a href=&#34;https://golang.org/pkg/runtime/#GOMAXPROCS&#34;&gt;GOMAXPROCS&lt;/a&gt; is.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CPU means logical CPU, of course. I modified workers example a bit to make a real work (not just sleep) and use real CPU time. Then I ran the code without any modification except setting different GOMAXPROCS value. The Linux box had 2 CPUs with 12 cores each, resulting in 24 cores.&lt;/p&gt;

&lt;p&gt;So, the first run demonstrates the program running on 1 core, and second - using the power of all 24 cores availiable.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/gomaxprocs1/&#34;&gt;WebGL animation - 1&lt;/a&gt; | &lt;a href=&#34;https://divan.github.io/demos/gomaxprocs24/&#34;&gt;WebGL animation - 24&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/gomaxprocs1.gif&#34; alt=&#34;GOMAXPROCS1&#34; /&gt; &lt;img src=&#34;https://divan.github.io/demos/gifs/gomaxprocs24.gif&#34; alt=&#34;GOMAXPROCS24&#34; /&gt;
The time speed in these animations are different (I wanted all animations to fit the same time/height), so the difference is obvious. With GOMAXPROCS=1, next worker start real work only after previous has finish it&amp;rsquo;s work. With GOMAXPROCS=24 the speedup is huge, and overhead for multiplexing is negligible.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important to understand, though, that increasing GOMAXPROCS not always boosts performance, and there cases when it actually makes it worse.&lt;/p&gt;

&lt;h3 id=&#34;goroutines-leak:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Goroutines leak&lt;/h3&gt;

&lt;p&gt;What else we can demonstrate from concurrent things in Go? The one thing that comes to my mind is a goroutines leak. A leak can happen, for example, if you &lt;a href=&#34;http://openmymind.net/Leaking-Goroutines/&#34;&gt;start goroutine but it falls out of scope&lt;/a&gt;. Or you simply forget to add finish condition, and run a for {} loop.&lt;/p&gt;

&lt;p&gt;First time I&amp;rsquo;ve encountered goroutine leak in my code, the scary image appeared in my head and I wrote &lt;a href=&#34;https://github.com/divan/expvarmon&#34;&gt;expvarmon&lt;/a&gt; next weekend. And now I can visualize that scary image with WebGL.&lt;/p&gt;

&lt;p&gt;Take a look:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/leak/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/leak.gif&#34; alt=&#34;Leak&#34; /&gt;
I feel pain even simply by looking at this :) All those lines are wasted resources and a ticking bomb for your program.&lt;/p&gt;

&lt;h3 id=&#34;parallelism-is-not-concurrency:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;Parallelism is not Concurrency&lt;/h3&gt;

&lt;p&gt;The last thing I want to illustrate is a difference between parallelism and concurrency. This topic is &lt;a href=&#34;https://existentialtype.wordpress.com/2011/03/17/parallelism-is-not-concurrency/&#34;&gt;well&lt;/a&gt; &lt;a href=&#34;https://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/&#34;&gt;covered&lt;/a&gt;, and there is a &lt;a href=&#34;https://www.youtube.com/watch?v=cN_DpYBzKso&#34;&gt;great talk by Rob Pike&lt;/a&gt; on the subject. One of the #mustwatch videos, really.&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;center&gt;
		&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;760&#34; height=&#34;457&#34; src=&#34;http://www.youtube.com/embed/cN_DpYBzKso&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
		&lt;/iframe&gt;
	&lt;/center&gt;
&lt;/div&gt;


&lt;p&gt;To be short,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Parallelism is simply running things in parallel.&lt;/p&gt;

&lt;p&gt;Concurrency is a way to structure your program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thus, the concurrent program may or may not be parallel, these concepts are somehow orthogonal. We have seen this earlier in a demonstration of GOMAXPROCS setting effects.&lt;/p&gt;

&lt;p&gt;I can repeat all those linked articles and talks, but a picture is worth a thousand words. What I can do here is to visualize the difference.
So, this is parallelism. Many things running in parallel.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/parallelism1/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/parallelism1.gif&#34; alt=&#34;Parallelism 1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this is also parallelism:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://divan.github.io/demos/parallelism2/&#34;&gt;Go to interactive WebGL animation&lt;/a&gt;
&lt;img src=&#34;https://divan.github.io/demos/gifs/parallelism2.gif&#34; alt=&#34;Parallelism 2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But this is concurrency:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/demos/gifs/primesieve.gif&#34; alt=&#34;PrimeSieve&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/demos/gifs/workers2.gif&#34; alt=&#34;Workers of workers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this is also concurrency:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/demos/gifs/pingpong100.gif&#34; alt=&#34;Ping-Pong 100&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-it-was-made:cacee17578a8ad02e42a5a54daf9c476&#34;&gt;How it was made&lt;/h3&gt;

&lt;p&gt;To create these animations, I wrote two programs: &lt;em&gt;gotracer&lt;/em&gt; and &lt;em&gt;gothree.js&lt;/em&gt; library.
First, gotracer does the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;parse AST tree of Go program and insert special commands with output on concurrency related events - start/stop goroutine, create a channel, send/receive to/from a channel.&lt;/li&gt;
&lt;li&gt;run generated program&lt;/li&gt;
&lt;li&gt;analyze this special output and produce JSON with the description of events and timestamps.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example of the resulting JSON:
&lt;img src=&#34;https://divan.github.io/images/sshot_json.png&#34; alt=&#34;JSON sample&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next, gothree.js uses the power of an amazing &lt;a href=&#34;http://threejs.org/&#34;&gt;Three.js&lt;/a&gt; library to draw 3D lines and objects using WebGL. Little wrapper to fit into single html page - and there it is.&lt;/p&gt;

&lt;p&gt;This approach, though, is super limited. I have to accurately choose examples, rename channels and goroutines to make more or less complex code to produce a correct trace. With this approach, there is no easy way to correllate channels between goroutines if they have different names. Not to mention channels sent over channels of type chan. There are also huge issues with timing - output to stdout can take more time than sending value, so in some cases I had to place time.Sleep(some amount of milliseconds) to get proper animation.&lt;/p&gt;

&lt;p&gt;Basically, that is a reason why I&amp;rsquo;m not open-sourcing the code yet. I&amp;rsquo;m playing with Dmitry Vyukov&amp;rsquo;s &lt;a href=&#34;https://golang.org/cmd/trace/&#34;&gt;execution tracer&lt;/a&gt;, it seems to provide good level of details of events, but do not contain info on which values are being sent. Maybe there are better ways to achieve the desired goal. Write me in twiter or in comments here, if you have ideas. It would be super great to extend this two-weekends tool to be a real debugging/tracing instrument suitable for any Go program.&lt;/p&gt;

&lt;p&gt;I also would be happy to visualize more interesting concurrent algorithms and patterns not listed here. Feel free to write ones in the comments.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to complain about Go</title>
      <link>https://divan.github.io/posts/go_complain_howto/</link>
      <pubDate>Mon, 14 Dec 2015 08:36:54 -0300</pubDate>
      
      <guid>https://divan.github.io/posts/go_complain_howto/</guid>
      <description>

&lt;p&gt;Over the years of existence of Go programming language, the articles with its critique was always popular, bringing a lot of discussion from both sides. Recently, &lt;a href=&#34;https://github.com/ksimka&#34;&gt;Maksim Kochkin&lt;/a&gt; even created GitHub repo with &lt;a href=&#34;https://github.com/ksimka/go-is-not-good&#34;&gt;curated list&lt;/a&gt; of articles complaining about golang&amp;rsquo;s imperfection.&lt;/p&gt;

&lt;p&gt;So, is it true that ranting about Go flaws is a trend nowadays? With carefully gathered links in the repository above, we can check this! :) Unfortunately, there are only 17 articles in the list, which is a bit disappointing because it&amp;rsquo;s not enough for fine statistical analysis, but we can use this anyway.&lt;/p&gt;

&lt;p&gt;Here is a trending line for the &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1qKFykmm0yapLq1FKuouvqVZkWo-HHCfJnrTikqRoAfs/edit#gid=1956718702&#34;&gt;number of Go complaints written per year&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/go_rants_trend.png&#34; alt=&#34;Trending&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The trending is obvious - from one in 2009 to five in 2015. Hopefully, the next 2016 year will continue this trend line.&lt;/p&gt;

&lt;p&gt;But what I liked most about this list - is a brief resume on the major authors&amp;rsquo; points. We can measure the popularity of users&amp;rsquo; complaints by counting aggregated points. Again, let&amp;rsquo;s do it in our Google Sheet document, which is written in Google, and probably involves a lot of production Go code to let us enjoy this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://divan.github.io/images/go_rants_top.png&#34; alt=&#34;Trending&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let me write again the top-5 winners:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;error handling / no exceptions&lt;/li&gt;
&lt;li&gt;no generics&lt;/li&gt;
&lt;li&gt;stuck in 70&amp;rsquo;s&lt;/li&gt;
&lt;li&gt;no OOP&lt;/li&gt;
&lt;li&gt;too opinionated&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Again, it&amp;rsquo;s a bit disappointing that absolute winner (&lt;em&gt;&amp;ldquo;error handling&amp;rdquo;&lt;/em&gt;) is mentioned only 7 times. Many thousands of people are using Go every day and only 7 put their major complaint into words in the form of a blog post? This flank definitely needs more support.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t like Go, you may contribute here. Especially if you tried Go before you started complaining about its design. But how to start the  article to make a proper effect? Take a look at these 5 top complaints and choose on which one you want elaborate.&lt;/p&gt;

&lt;p&gt;Keep in mind, &lt;em&gt;&amp;ldquo;error handling&amp;rdquo;&lt;/em&gt; and &lt;em&gt;&amp;ldquo;no generics&amp;rdquo;&lt;/em&gt; are absolute winners - you have absolutely no excuse not to add them to your list. Next, be careful with &lt;em&gt;&amp;ldquo;no OOP&amp;rdquo;&lt;/em&gt; because it&amp;rsquo;s easy to attack by quoting Alan Kay. &lt;em&gt;&amp;ldquo;Too opinionated&amp;rdquo;&lt;/em&gt; is a good choice, but should be carefully argued so you don&amp;rsquo;t look like a grouchy geek rather than a thoughtful hacker. &lt;em&gt;&amp;ldquo;Stuck in 70&amp;rsquo;s&amp;rdquo;&lt;/em&gt; works best if you want not only complain about Go but popularize another modern and objectively good programming language.&lt;/p&gt;

&lt;p&gt;But what if it&amp;rsquo;s not enough? There are 41 more other complaints scored 1 or 2 in the list, not including ones you can make up on your own! So, to help you make a choice, here are some rules and guidelines on how to properly complain about Go, depending on you previous background and experience.&lt;/p&gt;

&lt;p&gt;For example, if you come from&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;python:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;&amp;hellip;Python&lt;/h2&gt;

&lt;p&gt;We all love Python, so the attack vector should be on the maturity and abundance of libraries. NumPy is a must have point - Go still don&amp;rsquo;t have a scientific library of that quality. Not sure how SpaceX is able to use Go without one, but whatever, NumPy sells well.&lt;/p&gt;

&lt;p&gt;Try not to mention mature libraries like Twisted, Requests and various solutions for solving the 10K problem. Just don&amp;rsquo;t mention it. Instead, try to disprove relatively high memory usage in Python. For example, you can say that Python memory usage after goroutines leakage is competitive with Go. Someone from Mozilla &lt;a href=&#34;https://docs.google.com/presentation/d/1LO_WI3N-3p2Wp9PDWyv5B6EGFZ8XTOTNJ7Hd40WOUHo/mobilepresent?pli=1&amp;amp;slide=id.g70b0035b2_1_119&#34;&gt;said this&lt;/a&gt;, so can you.&lt;/p&gt;

&lt;p&gt;As a bonus, mention that Go slice indexing doesn&amp;rsquo;t have convenient -1 index. &lt;em&gt;&amp;ldquo;Is compiled&amp;rdquo;&lt;/em&gt; flaw also works here, without any explanation. Just because.&lt;/p&gt;

&lt;h2 id=&#34;c:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;&amp;hellip;C++&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re C++ developer, you are in the most vulnerable position, because Go was created as an answer to the C++ problems. Which easily can be muted or presented as powerful features.&lt;/p&gt;

&lt;p&gt;Start by demonizing GC. Everyone knows that Garbage Collection is an evil and every CPU tact matters. Even if you write simple REST-backend in C++ and it takes 6 months of your life to accomplish it - you still have speed and no-GC blissfulness. Stick with that.&lt;/p&gt;

&lt;p&gt;As a logical continuation - tell that Go is not good for embedded. Don&amp;rsquo;t mention that authors explicitly said that it was never meant as a language for embedded. It&amp;rsquo;s a great point anyway. And if your commenters will send you links to &lt;a href=&#34;http://embd.kidoman.io&#34;&gt;Embd&lt;/a&gt;, &lt;a href=&#34;http://gobot.io&#34;&gt;Gobot&lt;/a&gt; or &lt;a href=&#34;https://github.com/golang/mobile&#34;&gt;gomobile&lt;/a&gt;, just say that it&amp;rsquo;s not True Embedded or just disable comments.&lt;/p&gt;

&lt;p&gt;And, of course, all rants about how Go restricting you from shooting yourself in the foot are also great here. Go doesn&amp;rsquo;t make you feel clever than your coworker that bangs his head against the wall trying to understand your code. Why do you need such a language after all?&lt;/p&gt;

&lt;h2 id=&#34;rust:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;&amp;hellip;Rust&lt;/h2&gt;

&lt;p&gt;Despite the fact that there aren&amp;rsquo;t many people in the wild who can claim &amp;ldquo;background in Rust&amp;rdquo;, there are still a bunch of people from C++ background who are totally in love with Rust. They didn&amp;rsquo;t try it in production or even for pet projects, but that&amp;rsquo;s not important. Pure love doesn&amp;rsquo;t need logic. So, many points valid for C++ developers will work for you also. Don&amp;rsquo;t forget &lt;em&gt;&amp;ldquo;zero-cost abstraction&amp;rdquo;&lt;/em&gt; phrase after mentioning how evil GC is.&lt;/p&gt;

&lt;p&gt;Cargo is considered to be a good solution for dependency management, so attack this side of Go aggressively. No chance to lose here. Also, your key points should be Go&amp;rsquo;s simple type system and lack of pattern matching. Basically, everything that differs in Go from Rust will work here. And that&amp;rsquo;s a lot, so you can write a solid longread. Or two.&lt;/p&gt;

&lt;h2 id=&#34;java:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;&amp;hellip;Java&lt;/h2&gt;

&lt;p&gt;After mentioning generics and exceptions, punch them in the guts and smash them by comparing Java&amp;rsquo;s IDE with Go&amp;rsquo;s IDE. Of course, there is no Go IDE, because Go is too simple to require one, but it&amp;rsquo;s bad also. Double kick. It&amp;rsquo;s &amp;ldquo;advanced&amp;rdquo; vs &amp;ldquo;primitive&amp;rdquo; and you&amp;rsquo;re a winner here.&lt;/p&gt;

&lt;p&gt;Next, write about the lack of good debugger (integrated into IDE, of course). How can someone write even simple code without a debugger? Don&amp;rsquo;t ask if you really need debugger in Go that much as you need it in Java and why. Stay away from this subject, it&amp;rsquo;s slippery.&lt;/p&gt;

&lt;p&gt;And the whole range of &amp;lsquo;features&amp;rsquo; that you can use to make people understand why Go is bad - from lack of JVM to &lt;em&gt;&amp;ldquo;lack of basic data structures&amp;rdquo;&lt;/em&gt;. Take your time and improvise while your IDE starts.&lt;/p&gt;

&lt;h2 id=&#34;ruby:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;&amp;hellip;Ruby&lt;/h2&gt;

&lt;p&gt;If you come from Ruby and don&amp;rsquo;t really like Go, I probably won&amp;rsquo;t help you. Go is quite popular in Ruby community and many Ruby developers, being non-arrogant and pragmatic, fall into Go pretty easily, so you&amp;rsquo;re in trouble. Even Basecamp, the guys that made Ruby on Rails, &lt;a href=&#34;https://signalvnoise.com/posts/3897-go-at-basecamp&#34;&gt;love Go&lt;/a&gt; and use it inside. Sorry.&lt;/p&gt;

&lt;h2 id=&#34;d:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;&amp;hellip;D&lt;/h2&gt;

&lt;p&gt;Without any doubts, your main argument (after generics and exceptions, of course) should be the name of Google. It&amp;rsquo;s pretty much obvious that popularity of Go is simply a result of a huge money support by Google. Of course, Google pays people a lot to write articles about Go and to organize conferences and meetups. They are so rich, that next year Go community will have &lt;a href=&#34;https://github.com/golang/go/wiki/Conferences&#34;&gt;6 international conferences&lt;/a&gt; including one in &lt;a href=&#34;http://www.gophercon.ae/&#34;&gt;Dubai&lt;/a&gt;! When D have a company that can do the same for D, the world will understand that Go&amp;rsquo;s popularity is a fake.&lt;/p&gt;

&lt;p&gt;Also, Go is not a real system programming language. You can&amp;rsquo;t write your own memory allocator with Go. So switch to D. Please.&lt;/p&gt;

&lt;h2 id=&#34;perl:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;&amp;hellip;Perl&lt;/h2&gt;

&lt;p&gt;Emm..&lt;/p&gt;

&lt;h2 id=&#34;c-1:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;&amp;hellip;C#&lt;/h2&gt;

&lt;p&gt;Probably the best strategy here is to attack the simplicity of Go. Simplicity equals primitivity, everyone knows in MS world. Also Go is made by Google, not by MS, so it&amp;rsquo;s doomed. There are so many good solutions for modern programming language theory you learn in the college course of C#! But poor people behind Go just are not aware of them. Don&amp;rsquo;t hesitate to teach them. You can&amp;rsquo;t do pretty much anything with a language that primitive as Go.&lt;/p&gt;

&lt;p&gt;Also, mention the most relevant things - no Visual Studio support (&lt;a href=&#34;https://github.com/microsoft/vscode-go&#34;&gt;Visual Studio Code&amp;rsquo;s Go plugin&lt;/a&gt; doesn&amp;rsquo;t count). No debugger in IDE, of course. And no DirectX support, that&amp;rsquo;s important.&lt;/p&gt;

&lt;h2 id=&#34;haskell:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;&amp;hellip;Haskell&lt;/h2&gt;

&lt;p&gt;If you come from Haskell, I shouldn&amp;rsquo;t give you any advice. You already must be a professional in mocking Go. It&amp;rsquo;s in Haskell 101 course. New Haskell books contain special chapter &amp;ldquo;How to laugh on Go&amp;rdquo;, after all.&lt;/p&gt;

&lt;p&gt;Even if you &lt;a href=&#34;https://honza.ca/2015/11/language-choice&#34;&gt;intuitively understand&lt;/a&gt; that Go is way more practical than Haskell and entry barrier really matters - keep insisting that it has &amp;ldquo;objectively poor design&amp;rdquo;. Because everyone knows which language has objectively good design.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:959aee67c1d0f41b07629a76d2bb3194&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I hope this article will find its readers. In 2016, we need more articles with rants on Go - at least 6 to keep the trend. Some of the articles in the list above written by students and schoolboys, so if you just started CS class and don&amp;rsquo;t have any real-life experience - don&amp;rsquo;t hesitate to tell the world how bad Go is.&lt;/p&gt;

&lt;p&gt;After all, the viral effect of the articles with criticism is well known - colleagues and managers send you the link as a prove that you shouldn&amp;rsquo;t use Go in production, without even reading or analyzing its content. The title is usually enough, so don&amp;rsquo;t be afraid.&lt;/p&gt;

&lt;p&gt;Or.. you can just write some good code in the language that works best for your case.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Integration testing in Go using Docker</title>
      <link>https://divan.github.io/posts/integration_testing/</link>
      <pubDate>Mon, 07 Dec 2015 08:36:54 -0700</pubDate>
      
      <guid>https://divan.github.io/posts/integration_testing/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Note: this post was originally written for the &lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/introduction/&#34;&gt;Go Advent 2015&lt;/a&gt; series, but I discovered that a post with almost exactly the same subject (and even similar code!) already planned :) That&amp;rsquo;s amazing.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Golang is often used for writing microservices and various backends. Often these type of software do some computation, read/write data on external storage and expose it&amp;rsquo;s API via http handlers. All this functionality is remarkably easy to implement in Go and, especially if you&amp;rsquo;re creating &lt;a href=&#34;http://12factor.net&#34;&gt;12factor&lt;/a&gt;-compatible app, Go is your friend here.&lt;/p&gt;

&lt;p&gt;This functionality is also easy to test using built-in Go testing tooling. But here&amp;rsquo;s the catch - unit testing or &lt;em&gt;small tests&lt;/em&gt; doesn&amp;rsquo;t guarantee that your service is working correctly. Even if you simply want to test your HTTP response codes, you have to inject dependencies first and connect your code to the external resources or storage. At this point you&amp;rsquo;ll probably realize you need to write a proper integration test, which include not only your code but all dependent resources as well.&lt;/p&gt;

&lt;p&gt;But, how to do this without inventing your own scripts and harness code for mocking and starting services? How to make it as easy to use as a normal &amp;lsquo;go test&amp;rsquo; workflow? How to deal with setting up migrations and schemas for you databases? Finally, how to make it cross-platform, so you can easily run those tests on your Macbook as well as in your CI node?&lt;/p&gt;

&lt;p&gt;Let me show one of the possible solutions I use for a number of services for quite a long time. It leverages the power of &lt;a href=&#34;https://www.docker.com&#34;&gt;Docker&lt;/a&gt; isolation and comfort of go test tooling, and thus very easy to use and, with little efforts, gives you truly cross-platform integration testing.&lt;/p&gt;

&lt;p&gt;As an example I&amp;rsquo;ll take simple go-based webservice, which is often may be sufficient for REST-backends:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;REST-service based on &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;gin&lt;/a&gt; framework&lt;/li&gt;
&lt;li&gt;data storage - external MySQL database&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bitbucket.org/liamstask/goose/&#34;&gt;goose&lt;/a&gt; tool for migrations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker:23b513b340b05e75befe17e12589dce1&#34;&gt;Docker&lt;/h2&gt;

&lt;p&gt;So, yes, we will use &lt;a href=&#34;https://www.docker.com&#34;&gt;Docker&lt;/a&gt; to handle all external dependencies (MySQL database in our case), and that&amp;rsquo;s exactly the case where Docker shines. Nowadays internet is &lt;a href=&#34;http://ctankersley.com/2014/09/30/docker-a-misunderstood-tool/&#34;&gt;full&lt;/a&gt; of &lt;a href=&#34;http://www.rkn.io/2014/09/26/no-silver-bullets/&#34;&gt;articles&lt;/a&gt; and &lt;a href=&#34;https://speakerdeck.com/rjschwei/docker-not-a-silver-bullet&#34;&gt;talks&lt;/a&gt; telling that Docker is not a &amp;lsquo;silver bullet&amp;rsquo;, and &lt;a href=&#34;https://valdhaus.co/writings/docker-misconceptions/&#34;&gt;putting&lt;/a&gt; a &lt;a href=&#34;http://sirupsen.com/production-docker/&#34;&gt;lot of criticism&lt;/a&gt; on many docker use cases. Of course, they&amp;rsquo;re absolutely right and many of their points are valid, but in this particular case it&amp;rsquo;s exactly the case where you should use Docker. It gives us everything we need - repeatability, isolation, speed, and portability.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start by creating &lt;a href=&#34;http://docs.docker.com/engine/reference/builder/&#34;&gt;Dockerfile&lt;/a&gt; for our dependency service - MySQL database. Normally you would use official mysql docker image, but we have to wind up migrations with goose, so we&amp;rsquo;d better off creating our custom MySQL debian image:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;dockerfile&#34;&gt;FROM debian

ENV DEBIAN_FRONTEND noninteractive
RUN apt-get update
RUN apt-get install -y mysql-server

RUN sed -i -es/^bind-address\s*=\s*127.0.0.1/bind-address = 0.0.0.0/ /etc/mysql/my.cnf

RUN apt-get install -y golang git ca-certificates gcc
ENV GOPATH /root
RUN go get bitbucket.org/liamstask/goose/cmd/goose

ADD. /db
RUN \
service mysql start &amp;&amp; \
sleep 10 &amp;&amp; \
while true; do mysql -e SELECT 1 &amp;&gt; /dev/null; [ $? -eq 0 ] &amp;&amp; break; echo -n &#34;.&#34;; sleep 1; done &amp;&amp; \
mysql -e GRANT ALL ON *.* to &#39;root&#39;@&#39;%&#39;; FLUSH PRIVILEGES; &amp;&amp; \
mysql -e CREATE DATABASE mydb DEFAULT COLLATE utf8_general_ci; &amp;&amp; \
/root/bin/goose -env=production up &amp;&amp; \
service mysql stop

EXPOSE 3306
CMD [mysqld_safe]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we build our image with &lt;code&gt;docker build -t mydb_test .&lt;/code&gt; command and run it with &lt;code&gt;docker run -p 3306:3306 mydb_test&lt;/code&gt;. The resulting container will have a fresh actual database instance with the latest migrations applied. Once the image is built it takes less than a second to start this container.&lt;/p&gt;

&lt;p&gt;The actual name of container and database is not important here, so we use &lt;code&gt;mydb&lt;/code&gt; and &lt;code&gt;mydb_test&lt;/code&gt; - simply a convention.&lt;/p&gt;

&lt;h2 id=&#34;go-tests:23b513b340b05e75befe17e12589dce1&#34;&gt;Go tests&lt;/h2&gt;

&lt;p&gt;Now, it&amp;rsquo;s time to write some Go code. Remember, we want our test to be portable and issued with &lt;code&gt;go test&lt;/code&gt; command only. Let&amp;rsquo;s start our service_test.go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// +build integration

package main

import (
    &#34;testing&#34;
)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We place build tag &lt;code&gt;integration&lt;/code&gt; here to make sure this test will run only when explicitly asked with &lt;code&gt;--tags=integration&lt;/code&gt; flag. Yes, the test itself is fast, but still requires an external tool (Docker), so we&amp;rsquo;d better separate integration tests and unit tests.&lt;/p&gt;

&lt;p&gt;By the way, we could protect in with &lt;a href=&#34;https://golang.org/pkg/testing/#Short&#34;&gt;testing.Short&lt;/a&gt; flag, but the behavior is opposite in this case - long tests run by default.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
if testing.Short() {
        t.Skip(&#34;skipping test in short mode.&#34;)
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;running-docker-container:23b513b340b05e75befe17e12589dce1&#34;&gt;Running Docker container&lt;/h3&gt;

&lt;p&gt;Before running our tests, we need to start our dependencies. There are a few packages to work with &lt;a href=&#34;https://docs.docker.com/engine/reference/api/docker_remote_api/&#34;&gt;Docker Remote API&lt;/a&gt; for Go, I will use the &lt;a href=&#34;http://github.com/fsouza/go-dockerclient&#34;&gt;one from fsouza&lt;/a&gt;, which I successfully using for quite a long time. Install it with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;go get -u github.com/fsouza/go-dockerclient&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To start the container, we have to write following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;client, err := docker.NewClientFromEnv()
if err != nil {
    t.Fatalf(&#34;Cannot connect to Docker daemon: %s&#34;, err)
}
c, err := client.CreateContainer(createOptions(&#34;mydb_test&#34;))
if err != nil {
    t.Fatalf(&#34;Cannot create Docker container: %s&#34;, err)
}
defer func() {
    if err := client.RemoveContainer(docker.RemoveContainerOptions{
        ID:    c.ID,
        Force: true,
    }); err != nil {
        t.Fatalf(&#34;cannot remove container: %s&#34;, err)
    }
}()

err = client.StartContainer(c.ID, &amp;docker.HostConfig{})
if err != nil {
    t.Fatalf(&#34;Cannot start Docker container: %s&#34;, err)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;createOptions() is a helper function returning struct with container creating options. We pass our docker container name to that function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func reateOptions(dbname string) docker.CreateContainerOptions {
    ports := make(map[docker.Port]struct{})
    ports[&#34;3306&#34;] = struct{}{}
    opts := docker.CreateContainerOptions{
        Config: &amp;docker.Config{
            Image:        dbname,
            ExposedPorts: ports,
        },
    }

    return opts
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that we need to write code which will wait for DB to start, extract IP address for connection, form DSN for database/sql driver and open the actual connection:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// wait for container to wake up
if err := waitStarted(client, c.ID, 5*time.Second); err != nil {
    t.Fatalf(&#34;Couldn&#39;t reach MySQL server for testing, aborting.&#34;)
}
c, err = client.InspectContainer(c.ID)
if err != nil {
    t.Fatalf(&#34;Couldn&#39;t inspect container: %s&#34;, err)
}

// determine IP address for MySQL
ip = strings.TrimSpace(c.NetworkSettings.IPAddress)

// wait MySQL to wake up
if err := waitReachable(ip+&#34;:3306&#34;, 5*time.Second); err != nil {
    t.Fatalf(&#34;Couldn&#39;t reach MySQL server for testing, aborting.&#34;)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we wait for two actions to happen: first is to get network inside container up, so we can obtain it&amp;rsquo;s IP address, and second, is MySQL service being actually started. Waiting functions are a bit tricky, so here they are:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// waitReachable waits for hostport to became reachable for the maxWait time.
func waitReachable(hostport string, maxWait time.Duration) error {
    done := time.Now().Add(maxWait)
    for time.Now().Before(done) {
        c, err := net.Dial(&#34;tcp&#34;, hostport)
        if err == nil {
            c.Close()
            return nil
        }
        time.Sleep(100 * time.Millisecond)
    }
    return fmt.Errorf(&#34;cannot connect %v for %v&#34;, hostport, maxWait)
}

// waitStarted waits for a container to start for the maxWait time.
func waitStarted(client *docker.Client, id string, maxWait time.Duration) error {
    done := time.Now().Add(maxWait)
    for time.Now().Before(done) {
        c, err := client.InspectContainer(id)
        if err != nil {
            break
        }
        if c.State.Running {
            return nil
        }
        time.Sleep(100 * time.Millisecond)
    }
    return fmt.Errorf(&#34;cannot start container %s for %v&#34;, id, maxWait)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, it&amp;rsquo;s enough to work with our container, but here is another issue comes in - if you run MacOS X or Windows, you use Docker via the proxy virtual machine with tiny linux, &lt;code&gt;docker-machine&lt;/code&gt; (or its predecessor, &lt;code&gt;boot2docker&lt;/code&gt;). It means you should use docker-machine&amp;rsquo;s IP address and not real container IP, which is not exposed outside of the docker-host linux VM.&lt;/p&gt;

&lt;h3 id=&#34;tuning-for-portability:23b513b340b05e75befe17e12589dce1&#34;&gt;Tuning for portability&lt;/h3&gt;

&lt;p&gt;Again, let&amp;rsquo;s just write code to accomplish that, as it&amp;rsquo;s quite trivial:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// DockerMachineIP returns IP of docker-machine or boot2docker VM instance.
//
// If docker-machine or boot2docker is running and has IP, it will be used to
// connect to dockerized services (MySQL, etc).
//
// Basically, it adds support for MacOS X and Windows.
func DockerMachineIP() string {
    // Docker-machine is a modern solution for docker in MacOS X.
    // Try to detect it, with fallback to boot2docker
    var dockerMachine bool
    machine := os.Getenv(&#34;DOCKER_MACHINE_NAME&#34;)
    if machine != &#34;&#34; {
        dockerMachine = true
    }

    var buf bytes.Buffer

    var cmd *exec.Cmd
    if dockerMachine {
        cmd = exec.Command(&#34;docker-machine&#34;, &#34;ip&#34;, machine)
    } else {
        cmd = exec.Command(&#34;boot2docker&#34;, &#34;ip&#34;)
    }
    cmd.Stdout = &amp;buf

    if err := cmd.Run(); err != nil {
        // ignore error, as it&#39;s perfectly OK on Linux
        return &#34;&#34;
    }

    return buf.String()
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For working with docker-machine we will also need to pass port forwarding configuration in CreateContainerOptions.&lt;/p&gt;

&lt;p&gt;At this point, the amount of supporting code becomes quite notable, and it&amp;rsquo;s better to move all docker related code into separate a subpackage, perhaps in internal/ directory. Let&amp;rsquo;s name it &lt;code&gt;internal/dockertest&lt;/code&gt;. The source of this package can be &lt;a href=&#34;http://pastebin.com/faUUN0M1&#34;&gt;found here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;running-from-tests:23b513b340b05e75befe17e12589dce1&#34;&gt;Running from tests&lt;/h3&gt;

&lt;p&gt;Now, all we need is to import our &lt;code&gt;internal/dockertest&lt;/code&gt; subpackage and start MySQL with a single line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// start db in docker container
dsn, deferFn, err := dockertest.StartMysql()
if err != nil {
    t.Fatalf(&#34;cannot start mysql in container for testing: %s&#34;, err)
}
defer deferFn()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pass &lt;code&gt;dsn&lt;/code&gt; to sql.Open() or your own service init function, and your code will connect to the database inside the container.
Note, that StartMysql() returns also a defer function, which will properly stop and remove container. Our test code knows nothing about underlying mechanisms. It just works as if it was a normal MySQL resource.&lt;/p&gt;

&lt;h3 id=&#34;testing-http-endpoints:23b513b340b05e75befe17e12589dce1&#34;&gt;Testing http endpoints&lt;/h3&gt;

&lt;p&gt;Next step is to test http-endpoints. We may want to test response codes, proper error messages, expected headers or data format and so on. And, following our desire to not depend on any external testing scripts, we want to run all the tests within the Go code. And Go allows us to do so using net/http/httptest package.&lt;/p&gt;

&lt;p&gt;Honestly, &lt;code&gt;httptest&lt;/code&gt; was one of the most surprising things in Go, when I first saw it. net/http design was quite unusual and elegant for me, but httptest looked like a killer feature for testing http services. It leverages the power of interfaces in Go, and particularly, the http.ResponseWriter interface to achieve in-memory round-trip of http requests. We don&amp;rsquo;t need to ask OS to open ports, deal with permissions and busy ports - it&amp;rsquo;s all in memory.&lt;/p&gt;

&lt;p&gt;And as soon as gin framework implements http.Handler interface, which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can use it transparently with httptest. I will also use amazing GoConvey testing framework, which implements behaviour-driven testing for Go, and fully compatible with the default &lt;code&gt;go test&lt;/code&gt; workflow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func NewServer(db *sql.DB) *gin.Engine {
    r := gin.Default()
    r.Use(cors.Middleware(cors.Options{}))
    // more middlewares ...

    // Health check
    r.GET(&#34;/ping&#34;, ping)

    // CRUD resources
    usersRes := &amp;UsersResource{db: db}

    // Define routes
    api := r.Group(&#34;/api&#34;)
    {
        v1 := api.Group(&#34;/v1&#34;)
        {
            rest.CRUD(v1, &#34;/users&#34;, usersRes)
        }
    }

    return r
}
...
r := NewServer(db)
Convey(&#34;Users endpoints should respond correctly&#34;, t, func() {
    Convey(&#34;User should return empty list&#34;, func() {
        // it&#39;s safe to ignore error here, because we&#39;re manually entering URL
        req, _ := http.NewRequest(&#34;GET&#34;, &#34;http://localhost/api/v1/users&#34;, nil)
        w := httptest.NewRecorder()
        r.ServeHTTP(w, req)

        So(w.Code, ShouldEqual, http.StatusOK)
        body := strings.TrimSpace(w.Body.String())
        So(body, ShouldEqual, &#34;[]&#34;)
    })
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GoConvey has also an astonishing web UI, I guarantee you will start writing more tests just to see that nice blinking &amp;ldquo;PASS&amp;rdquo; message! :)&lt;/p&gt;

&lt;p&gt;And now, after you get the idea, we can add more tests for testing basic CRUD functionality for our simple service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;Convey(&#34;Create should return ID of a newly created user&#34;, func() {
    user := &amp;User{Name: &#34;Test user&#34;}
    data, err := json.Marshal(user)
    So(err, ShouldBeNil)
    buf := bytes.NewBuffer(data)
    req, err := http.NewRequest(&#34;POST&#34;, &#34;http://localhost/api/v1/users&#34;, buf)
    So(err, ShouldBeNil)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, req)

    So(w.Code, ShouldEqual, http.StatusOK)
    body := strings.TrimSpace(w.Body.String())
    So(body, ShouldEqual, &#34;1&#34;)
})
Convey(&#34;List should return one user with name &#39;Test user&#39;&#34;, func() {
    req, _ := http.NewRequest(&#34;GET&#34;, &#34;http://localhost/api/v1/users&#34;, nil)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, req)

    So(w.Code, ShouldEqual, http.StatusOK)
    body := w.Body.Bytes()
    var users []*User
    err := json.Unmarshal(body, &amp;users)
    So(err, ShouldBeNil)
    user := &amp;User{
        ID: 1,
        Name: &#34;Test user&#34;,
    }
    So(len(users), ShouldEqual, 1)
    So(users[0], ShouldResemble, user)
})&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion:23b513b340b05e75befe17e12589dce1&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;As you may see, Go not only make testing a lot easiers but also make use of BDD and TDD methodologies very easy to follow and opens new possibilities for cross-platform integration- and acceptance- testing.&lt;/p&gt;

&lt;p&gt;This example provided here is simplified on purpose, but it&amp;rsquo;s based on the real production code which is being tested in this way for more than 1.5 years and survived a number of refactorings and migrations&amp;rsquo; updates. On my Macbook Air, the whole test, from start to end (compile code, run docker container in docker-machine and test ~35 http requests, shut down the container) it takes about 3 seconds. On native Linux system it&amp;rsquo;s obviously a lot faster.&lt;/p&gt;

&lt;p&gt;One may ask why not publish this code as a separate library, and make the whole task (and article) even shorter. But the point here is that for every different service there may be a different set of service connections, different usage patterns and so on. And what is really important is that with Go it&amp;rsquo;s so easy to write this harness code for your needs, that you don&amp;rsquo;t have an excuse not to do this. Whether you need many similar containers in parallel (probably, you&amp;rsquo;ll need to randomize exposed ports), or you have to interconnect some services before starting them - you just write in Go, hiding all the complexity from the actual testing code.&lt;/p&gt;

&lt;p&gt;And always write tests! There is not excuse not to write them anymore.&lt;/p&gt;

&lt;p&gt;UPD: After writing the article, discovered the package &lt;a href=&#34;https://github.com/ory-am/dockertest&#34;&gt;dockertest&lt;/a&gt; by Aeneas Rekkas (&lt;a href=&#34;https://twitter.com/_aeneasr&#34;&gt;@_aeneasr&lt;/a&gt;), which does almost exactly the same as a code in this article, and looks pretty solid. Don&amp;rsquo;t miss it out!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Explaining Go error handling</title>
      <link>https://divan.github.io/posts/go_errors/</link>
      <pubDate>Mon, 02 Nov 2015 08:36:54 -0700</pubDate>
      
      <guid>https://divan.github.io/posts/go_errors/</guid>
      <description>&lt;p&gt;I recently translated great article&lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Errors are values&lt;/a&gt; by Rob Pikeand we discussed it in our &lt;a href=&#34;https://golangshow.com/&#34;&gt;podcast Golangshow&lt;/a&gt; (in russian). One thing I was surprised about is that even experienced Go developers sometimes do not understand the core idea of that article.&lt;/p&gt;

&lt;p&gt;Looking back, I remember my first impressions when I read it for the first time. It was similar to &lt;em&gt;It looks like Pike just adds some complexity to what couldve been solved gracefully with exceptions&lt;/em&gt;. I have never been fond of exceptions, but thats the first thought I remember. The example in the article was clearly asking for comparison with exceptions way to deal with errors and it didnt look like a winner here.&lt;/p&gt;

&lt;p&gt;Still I knew, there must be something more profound in these words&lt;em&gt;errors are values&lt;/em&gt;. After all, I was always comfortable with Go errors handling, so I gave some time to myself to absorb the article.&lt;/p&gt;

&lt;p&gt;And then I got it.&lt;/p&gt;

&lt;p&gt;Go doesnt want us to treat errors as something different from our main code. Erroneous situation is a first-class citizen in program flow design.&lt;/p&gt;

&lt;blockquote&gt;Errors shouldnt be hidden or ignored in the same way as you dont hide or ignore any other code. They are part of your logic and code.&lt;/blockquote&gt;

&lt;p&gt;Just try to imagine your way of thinking when you deal with usual conceptsvalues, conditions, loops etc., and apply it to the errors. Errors are the same level entities as the rest of your code. You dont ignore return values of other types for no reason, right? You dont ask language to bring special way to handle boolean variables, because if is boring. You dont ask yourself What should I do, if I dont know what to do with this slice on this abstraction level?. You just program the logic you need.&lt;/p&gt;

&lt;p&gt;Again, errors are values, and errors handling is a normal programming.&lt;/p&gt;

&lt;p&gt;Of course, there are always some patterns to deal with errors (like with any other programming conception), but they emerge naturally and fit perfectly in the existing language capabilities.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Lets try to illustrate it with an example, close enough to that one in the original article. Say, you have a taskmake repetitive writes with io.Writer and calculate number of bytes written, and stop after 1024-th byte. You start with straightforward approach:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var count, n int
n = write(one)
count += n
if count &gt;= 1024 {
    return
}

n = write(two)
count += n
if count &gt;= 1024 {
    return
}
// etc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/8033Wp9xly&#34;&gt;http://play.golang.org/p/8033Wp9xly&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Of course, you instantly see whats wrong with this code and, following DRY principle, you decide to deduplicate code, moving repeating parts to separate function or closure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var count int
cntWrite := func(s string) {
  n := write(s)
  count += n
  if count &gt;= 1024 {
    os.Exit(0)
  }
}

cntWrite(one)
cntWrite(two)
cntWrite(three)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/Hd12rk6wNk&#34;&gt;http://play.golang.org/p/Hd12rk6wNk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now its better, but still not perfect. You still need a closure, which depends on external variable. It also uses os.Exit(), which makes it hardly reusable after first refactoring. We can do better. Lets see how our thoughts flowwe have a write function, which does something else, except just writing bytes and we need it to be reusable and isolated entity. Lets refactor our code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type cntWriter struct {
    count int
    w io.Writer
}

func (cw *cntWriter) write(s string) {
    if cw.count &gt;= 1024 {
        return 
    }
    n := write(s)
    cw.count += n
}

func (cw *cntWriter) written() int { return cw.count }

func main() {
    cw := &amp;cntWriter{}
    cw.write(one)
    cw.write(two)
    cw.write(three)
    fmt.Printf(Written %d bytes\n, cw.written())
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/66Xd1fD8II&#34;&gt;http://play.golang.org/p/66Xd1fD8II&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now it looks much better, we can reuse this custom writer in other functions, its isolated and easy to test.&lt;/p&gt;

&lt;p&gt;Now, just replace counter with error value and youll get almost the same example as in original article about error handling. But take a note how easy and logical was your flow of thoughts towards this code. You wasnt distracted by looking for the special counting/passing features of the language. You simply was implementing the logic you need in the best possible way.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;This idea is profound enough and could be hard to grasp, especially with the mindset focused on The Only Right Way To Handle Errors. It definitely takes some time to absorb.&lt;/p&gt;

&lt;p&gt;Of course, its debatable, and I can find both a lot of pros and cons for this approach, as well as for others. Were not in the black&amp;amp;white world, but Go approach to errors is kind of mature and fresh at the same time, it extremely simple and hard to understand at the same time, it requires some rethinking and effort to get the idea. But, what is more important, it works great in practice.&lt;/p&gt;

&lt;p&gt;And once you get it, you stop fight the language. You stop looking for special ways to handle or hide errors. Go makes you respect errors as any other part of your program. You just handle them, without expecting language do the magic for you. In the long run, your code becomes better, even if do not realize it yet.&lt;/p&gt;

&lt;p&gt;Now, come and read this article again&lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Errors are values&lt;/a&gt;and try to get the gist of it with this perspective.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>